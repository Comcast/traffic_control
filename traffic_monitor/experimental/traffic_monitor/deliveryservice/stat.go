package deliveryservice

import (
	"errors"
	"fmt"
	"github.com/Comcast/traffic_control/traffic_monitor/experimental/traffic_monitor/cache"
	"github.com/Comcast/traffic_control/traffic_monitor/experimental/traffic_monitor/peer"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// TODO remove 'ds' and 'stat' from names

// TODO move name string types somewhere more generic

type CacheName string

type CacheGroupName string

// Current JSON endpoint:
type DeliveryServiceName string

// New, more structured format:
type StatMeta struct {
	Time int `json:"time"`
}
type StatFloat struct {
	StatMeta
	Value float64 `json:"value"`
}
type StatBool struct {
	StatMeta
	Value bool `json:"value"`
}
type StatInt struct {
	StatMeta
	Value int64 `json:"value"`
}
type StatString struct {
	StatMeta
	Value string `json:"value"`
}

// StatCacheStats is all the stats generated by a cache.
// This may also be used for aggregate stats, for example, the summary of all cache stats for a cache group, or delivery service.
// Each stat is an array, in case there are multiple data points at different times. However, a single data point i.e. a single array member is common.
type StatCacheStats struct {
	OutBytes    StatInt    `json:"out_bytes"`
	IsAvailable StatBool   `json:"is_available"`
	Status5xx   StatInt    `json:"status_5xx"`
	Status4xx   StatInt    `json:"status_4xx"`
	Status3xx   StatInt    `json:"status_3xx"`
	Status2xx   StatInt    `json:"status_2xx"`
	InBytes     StatFloat  `json:"in_bytes"`
	Kbps        StatFloat  `json:"kbps"`
	Tps5xx      StatInt    `json:"tps_5xx"`
	Tps4xx      StatInt    `json:"tps_4xx"`
	Tps3xx      StatInt    `json:"tps_3xx"`
	Tps2xx      StatInt    `json:"tps_2xx"`
	ErrorString StatString `json:"error_string"`
	TpsTotal    StatInt    `json:"tps_total"`
}

// TODO move and rename more generically
type StatCacheType string

const StatCacheTypeEdge = StatCacheType("EDGE")
const StatCacheTypeMid = StatCacheType("MID")
const StatCacheTypeInvalid = StatCacheType("INVALID")

func (t StatCacheType) String() string {
	switch t {
	case StatCacheTypeEdge:
		return "EDGE"
	case StatCacheTypeMid:
		return "MID"
	default:
		return "INVALID"
	}
}

func StatCacheTypeFromString(s string) StatCacheType {
	s = strings.ToLower(s)
	switch s {
	case "edge":
		return StatCacheTypeEdge
	case "mid":
		return StatCacheTypeMid
	default:
		return StatCacheTypeInvalid
	}
}

type StatType int64

const (
	StatTypeHTTP = iota
	StatTypeDNS
	StatTypeInvalid
)

func (t StatType) String() string {
	switch t {
	case StatTypeHTTP:
		return "HTTP"
	case StatTypeDNS:
		return "DNS"
	default:
		return "INVALID"
	}
}

func StatTypeFromString(s string) StatType {
	s = strings.ToLower(s)
	switch s {
	case "http":
		return StatTypeHTTP
	case "dns":
		return StatTypeDNS
	default:
		return StatTypeInvalid
	}
}

type StatCommon struct {
	CachesConfigured StatInt            `json:"caches_configured"`
	CachesReporting  map[CacheName]bool `json:"caches_reporting"`
	ErrorString      StatString         `json:"error_string"`
	Status           StatString         `json:"status"`
	IsHealthy        StatBool           `json:"is_healthy"`
	IsAvailable      StatBool           `json:"is_available"`
	CachesAvailable  StatInt            `json:"caches_available"`
}

type Stat interface {
	StatType() StatType
	CommonData() *StatCommon
}

type StatHTTP struct {
	Common      StatCommon
	CacheGroups map[CacheGroupName]StatCacheStats
	Type        map[StatCacheType]StatCacheStats
	Total       StatCacheStats
}

func (d StatHTTP) StatType() StatType {
	return StatTypeHTTP
}

func (d *StatHTTP) CommonData() *StatCommon {
	return &d.Common
}

func newStatHTTP() *StatHTTP {
	return &StatHTTP{CacheGroups: map[CacheGroupName]StatCacheStats{}, Type: map[StatCacheType]StatCacheStats{}, Common: StatCommon{CachesReporting: map[CacheName]bool{}}}
}

type StatDNS struct {
	Common StatCommon
}

func (d StatDNS) StatType() StatType {
	return StatTypeDNS
}

func (d *StatDNS) CommonData() *StatCommon {
	return &d.Common
}

func newStatDNS() *StatDNS {
	return &StatDNS{Common: StatCommon{CachesReporting: map[CacheName]bool{}}}
}

// TODO remove DeliveryService and set type to the map directly, or add other members
type Stats struct {
	DeliveryService map[DeliveryServiceName]Stat `json:"deliveryService"`
}

// TODO rename to just 'New'?
func NewStats() Stats {
	return Stats{DeliveryService: map[DeliveryServiceName]Stat{}}
}

// DsRegexes maps Delivery Service Regular Expressions to delivery services.
// For performance, we categorize Regular Expressions into 3 categories:
// 1. Direct string matches, with no regular expression matching characters
// 2. .*\.foo\..* expressions, where foo is a direct string match with no regular expression matching characters
// 3. Everything else
// This allows us to do a cheap match on 1 and 2, and only regex match the uncommon case.
// TODO performance tests, whether Go compiled *Regexp is relevantly slower than `strings.Contains` for direct and .foo. matches
type Regexes struct {
	DirectMatches                      map[string]DeliveryServiceName
	DotStartSlashDotFooSlashDotDotStar map[string]DeliveryServiceName
	RegexMatch                         map[*regexp.Regexp]DeliveryServiceName
}

// DeliveryService returns the delivery service which matches the given fqdn, or false.
func (d Regexes) DeliveryService(fqdn string) (DeliveryServiceName, bool) {
	if ds, ok := d.DirectMatches[fqdn]; ok {
		return ds, true
	}
	for matchStr, ds := range d.DotStartSlashDotFooSlashDotDotStar {
		if strings.Contains(fqdn, "."+matchStr+".") {
			return ds, true
		}
	}
	for regex, ds := range d.RegexMatch {
		if regex.MatchString(fqdn) {
			return ds, true
		}
	}
	return "", false
}

// TODO precompute; call when we get new delivery services, instead of every time we create new stats
func CreateRegexes(dsToRegex map[string][]string) (Regexes, error) {
	dsRegexes := Regexes{
		DirectMatches:                      map[string]DeliveryServiceName{},
		DotStartSlashDotFooSlashDotDotStar: map[string]DeliveryServiceName{},
		RegexMatch:                         map[*regexp.Regexp]DeliveryServiceName{},
	}

	for dsStr, regexStrs := range dsToRegex {
		ds := DeliveryServiceName(dsStr)
		for _, regexStr := range regexStrs {
			prefix := `.*\.`
			suffix := `\..*`
			if strings.HasPrefix(regexStr, prefix) && strings.HasSuffix(regexStr, suffix) {
				matchStr := regexStr[len(prefix) : len(regexStr)-len(suffix)]
				if otherDs, ok := dsRegexes.DotStartSlashDotFooSlashDotDotStar[matchStr]; ok {
					return dsRegexes, fmt.Errorf("duplicate regex %s (%s) in %s and %s", regexStr, matchStr, ds, otherDs)
				}
				dsRegexes.DotStartSlashDotFooSlashDotDotStar[matchStr] = ds
				continue
			}
			if !strings.ContainsAny(regexStr, `[]^\:{}()|?+*,=%@<>!'`) {
				if otherDs, ok := dsRegexes.DirectMatches[regexStr]; ok {
					return dsRegexes, fmt.Errorf("duplicate Regex %s in %s and %s", regexStr, ds, otherDs)
				}
				dsRegexes.DirectMatches[regexStr] = ds
				continue
			}
			// TODO warn? regex matches are unusual
			r, err := regexp.Compile(regexStr)
			if err != nil {
				return dsRegexes, fmt.Errorf("regex %s failed to compile: %v", regexStr, err)
			}
			dsRegexes.RegexMatch[r] = ds
		}
	}
	return dsRegexes, nil
}

func setStaticData(dsStats Stats, dsServers map[string][]string) Stats {
	for ds, istat := range dsStats.DeliveryService {
		istat.CommonData().CachesConfigured.Value = int64(len(dsServers[string(ds)]))
	}
	return dsStats
}

func addAvailableData(dsStats Stats, crStates peer.Crstates, serverCachegroups map[string]string, serverDs map[string]string, serverTypes map[string]StatCacheType) (Stats, error) {
	for cache, available := range crStates.Caches {
		cacheGroup, ok := serverCachegroups[cache]
		if !ok {
			fmt.Printf("WARNING: CreateStats not adding availability data for '%s': not found in Cachegroups\n", cache)
			continue
		}
		deliveryService, ok := serverDs[cache]
		if !ok {
			fmt.Printf("WARNING: CreateStats not adding availability data for '%s': not found in DeliveryServices\n", cache)
			continue
		}
		cacheType, ok := serverTypes[cache]
		if !ok {
			fmt.Printf("WARNING: CreateStats not adding availability data for '%s': not found in Server Types\n", cache)
			continue
		}

		iStat, ok := dsStats.DeliveryService[DeliveryServiceName(deliveryService)]
		if !ok || iStat == nil {
			fmt.Printf("WARNING: CreateStats not adding availability data for '%s': not found in Stats\n", cache)
			continue // TODO log warning? Error?
		}

		if available.IsAvailable {
			iStat.CommonData().IsAvailable.Value = true
			if stat, ok := iStat.(*StatHTTP); ok {
				cacheGroupStats := stat.CacheGroups[CacheGroupName(cacheGroup)]
				cacheGroupStats.IsAvailable.Value = true
				stat.CacheGroups[CacheGroupName(cacheGroup)] = cacheGroupStats
				stat.Total.IsAvailable.Value = true
				typeStats := stat.Type[cacheType]
				typeStats.IsAvailable.Value = true
				stat.Type[cacheType] = typeStats
			} else if _, ok := iStat.(*StatDNS); ok {
			} else {
				return dsStats, fmt.Errorf("Unknown stat type for Delivery Service '%s': %v", deliveryService, iStat)
			}
		}

		dsStats.DeliveryService[DeliveryServiceName(deliveryService)] = iStat // TODO Necessary? Remove?
	}
	return dsStats, nil
}

type StatsLastKbps struct {
	DeliveryServices map[DeliveryServiceName]StatLastKbps
	Caches           map[CacheName]LastKbpsData
}

func NewStatsLastKbps() StatsLastKbps {
	return StatsLastKbps{DeliveryServices: map[DeliveryServiceName]StatLastKbps{}, Caches: map[CacheName]LastKbpsData{}}
}

// TODO figure a way to associate this type with StatHTTP, with which its members correspond.
type StatLastKbps struct {
	CacheGroups map[CacheGroupName]LastKbpsData
	Type        map[StatCacheType]LastKbpsData
	Total       LastKbpsData
}

func newStatLastKbps() StatLastKbps {
	return StatLastKbps{CacheGroups: map[CacheGroupName]LastKbpsData{}, Type: map[StatCacheType]LastKbpsData{}}
}

type LastKbpsData struct {
	Kbps  float64
	Bytes int64
	Time  time.Time
}

// addKbps adds Kbps fields to the NewStats, based on the previous out_bytes in the oldStats, and the time difference.
//
// Traffic Server only updates its data every N seconds. So, often we get a new Stats with the same OutBytes as the previous one,
// So, we must record the last changed value, and the time it changed. Then, if the new OutBytes is different from the previous,
// we set the (new - old) / lastChangedTime as the KBPS, and update the recorded LastChangedTime and LastChangedValue
//
// This specifically returns the given dsStats and lastKbpsStats on error, so it's safe to do persistentStats, persistentLastKbpsStats, err = addKbps(...)
func addKbps(dsStats Stats, lastKbpsStats StatsLastKbps, dsStatsTime time.Time, cacheOutbytes map[CacheName]int64) (Stats, StatsLastKbps, error) {
	for dsName, iStat := range dsStats.DeliveryService {
		if _, ok := iStat.(*StatDNS); ok {
			continue
		}
		if _, ok := iStat.(*StatHTTP); !ok {
			fmt.Printf("WARNING: addKbps got unknown stat type %T\n", iStat)
			continue
		}
		stat := iStat.(*StatHTTP)

		lastKbpsStat, lastKbpsStatExists := lastKbpsStats.DeliveryServices[dsName]
		if !lastKbpsStatExists {
			lastKbpsStat = newStatLastKbps()
		}

		for cgName, cacheStats := range stat.CacheGroups {
			lastKbpsData, _ := lastKbpsStat.CacheGroups[cgName]

			if cacheStats.OutBytes.Value == lastKbpsData.Bytes {
				cacheStats.Kbps.Value = lastKbpsData.Kbps
				stat.CacheGroups[cgName] = cacheStats
				continue
			}

			if lastKbpsStatExists {
				cacheStats.Kbps.Value = float64(cacheStats.OutBytes.Value-lastKbpsData.Bytes) / dsStatsTime.Sub(lastKbpsData.Time).Seconds()
			}

			lastKbpsStat.CacheGroups[cgName] = LastKbpsData{Time: dsStatsTime, Bytes: cacheStats.OutBytes.Value, Kbps: cacheStats.Kbps.Value}
			stat.CacheGroups[cgName] = cacheStats
		}

		for cacheType, cacheStats := range stat.Type {
			lastKbpsData, _ := lastKbpsStat.Type[cacheType]
			if cacheStats.OutBytes.Value == lastKbpsData.Bytes {
				if cacheStats.OutBytes.Value == lastKbpsData.Bytes {
					cacheStats.Kbps.Value = lastKbpsData.Kbps
					stat.Type[cacheType] = cacheStats
					continue
				}
				if lastKbpsStatExists {
					cacheStats.Kbps.Value = float64(cacheStats.OutBytes.Value-lastKbpsData.Bytes) / dsStatsTime.Sub(lastKbpsData.Time).Seconds()
				}
				lastKbpsStat.Type[cacheType] = LastKbpsData{Time: dsStatsTime, Bytes: cacheStats.OutBytes.Value, Kbps: cacheStats.Kbps.Value}
				stat.Type[cacheType] = cacheStats
			}
		}
		if lastKbpsStatExists {
			stat.Total.Kbps.Value = float64(stat.Total.OutBytes.Value-lastKbpsStat.Total.Bytes) / dsStatsTime.Sub(lastKbpsStat.Total.Time).Seconds()
		} else {
			stat.Total.Kbps.Value = lastKbpsStat.Total.Kbps
		}
		lastKbpsStat.Total = LastKbpsData{Time: dsStatsTime, Bytes: stat.Total.OutBytes.Value, Kbps: stat.Total.Kbps.Value}

		lastKbpsStats.DeliveryServices[dsName] = lastKbpsStat
	}

	for cacheName, outBytes := range cacheOutbytes { // map[CacheName]int64
		lastCacheKbpsData, ok := lastKbpsStats.Caches[cacheName]
		if !ok {
			lastKbpsStats.Caches[cacheName] = LastKbpsData{Time: dsStatsTime, Bytes: outBytes, Kbps: 0}
			continue
		}

		if lastCacheKbpsData.Bytes == outBytes {
			continue // don't try to kbps, and importantly don't change the time of the last change, if Traffic Server hasn't updated
		}

		kbps := float64(outBytes-lastCacheKbpsData.Bytes) / dsStatsTime.Sub(lastCacheKbpsData.Time).Seconds()
		lastKbpsStats.Caches[cacheName] = LastKbpsData{Time: dsStatsTime, Bytes: outBytes, Kbps: kbps}
	}

	return dsStats, lastKbpsStats, nil
}

func CreateStats(statHistory map[string][]interface{}, dsServers map[string][]string, serverDs map[string]string, dsTypes map[string]StatType, dsRegexStrs map[string][]string, serverCachegroups map[string]string, serverTypes map[string]StatCacheType, crStates peer.Crstates, lastKbpsStats StatsLastKbps, now time.Time) (Stats, StatsLastKbps, error) {
	dsStats := NewStats()

	dsRegexes, err := CreateRegexes(dsRegexStrs)
	if err != nil {
		return Stats{}, lastKbpsStats, fmt.Errorf("error creating Regexes: %v", err)
	}

	for deliveryService, _ := range dsServers {
		dsType, ok := dsTypes[deliveryService]
		if !ok {
			return Stats{}, lastKbpsStats, fmt.Errorf("deliveryservice %s missing type", deliveryService)
		}
		if dsType == StatTypeHTTP {
			dsStats.DeliveryService[DeliveryServiceName(deliveryService)] = newStatHTTP()
		} else if dsType == StatTypeDNS {
			dsStats.DeliveryService[DeliveryServiceName(deliveryService)] = newStatDNS()
		} else {
			return Stats{}, lastKbpsStats, fmt.Errorf("unknown type for '%s': %v", deliveryService, dsType)
		}
	}

	dsStats = setStaticData(dsStats, dsServers)
	dsStats, err = addAvailableData(dsStats, crStates, serverCachegroups, serverDs, serverTypes)
	if err != nil {
		return dsStats, lastKbpsStats, fmt.Errorf("Error getting Cache availability data: %v", err)
	}

	stats := dsStats.DeliveryService

	cacheOutbytes := map[CacheName]int64{}

	for server, history := range statHistory {
		cachegroup, ok := serverCachegroups[server]
		if !ok {
			fmt.Printf("WARNING server %s has no cachegroup, skipping\n", server)
			continue
		}
		serverType, ok := serverTypes[server]
		if !ok {
			fmt.Printf("WARNING server %s not in CRConfig, skipping\n", server)
			continue
		}
		for _, iresult := range history {
			result, ok := iresult.(cache.Result)
			if !ok {
				fmt.Printf("ERROR history contained unexpected result type %T\n", iresult)
				continue
			}
			for stat, value := range result.Astats.Ats {

				if strings.HasSuffix(stat, ".out_bytes") {
					v, ok := value.(float64)
					if !ok {
						continue // no warning, because the same error will be returned by processStat
					}
					cacheOutbytes[CacheName(server)] += int64(v)
				}

				ds, newstat, err := processStat(&dsStats, dsRegexes, dsTypes, cachegroup, server, serverType, stat, value)
				if err == ErrNotProcessedStat {
					continue
				}
				if err != nil {
					if !strings.HasPrefix(err.Error(), "stat has unknown initial part") && !strings.HasSuffix(err.Error(), "matched no delivery service") {
						fmt.Printf("ERROR CreateStats failed to processStat for cachegroup '%s' server '%s' stat '%s': %v\n", cachegroup, server, stat, err)
					}
					continue
				}
				stats[ds] = newstat
			}
		}
	}
	dsStats.DeliveryService = stats

	return addKbps(dsStats, lastKbpsStats, now, cacheOutbytes)
}

var ErrNotProcessedStat = errors.New("This stat is not used.")

// processStat and its subsidiary functions act as a State Machine, flowing the stat thru states for each "." component of the stat name
func processStat(dsStats *Stats, dsRegexes Regexes, dsTypes map[string]StatType, cachegroup string, server string, serverType StatCacheType, stat string, value interface{}) (DeliveryServiceName, Stat, error) {
	parts := strings.Split(stat, ".")
	if len(parts) < 1 {
		return "", nil, fmt.Errorf("stat has no initial part")
	}

	switch parts[0] {
	case "plugin":
		return processStatPlugin(dsStats, dsRegexes, dsTypes, cachegroup, server, serverType, stat, parts[1:], value)
	case "proxy":
		return "", nil, ErrNotProcessedStat
	default:
		return "", nil, fmt.Errorf("stat has unknown initial part '%s'", parts[0])
	}
}

func processStatPlugin(dsStats *Stats, dsRegexes Regexes, dsTypes map[string]StatType, cachegroup string, server string, serverType StatCacheType, stat string, statParts []string, value interface{}) (DeliveryServiceName, Stat, error) {
	if len(statParts) < 1 {
		return "", nil, fmt.Errorf("stat has no plugin part")
	}
	switch statParts[0] {
	case "remap_stats":
		return processStatPluginRemapStats(dsStats, dsRegexes, dsTypes, cachegroup, server, serverType, stat, statParts[1:], value)
	default:
		return "", nil, fmt.Errorf("stat has unknown plugin part '%s'", statParts[0])
	}
}

func processStatPluginRemapStats(dsStats *Stats, dsRegexes Regexes, dsTypes map[string]StatType, cachegroup string, server string, serverType StatCacheType, stat string, statParts []string, value interface{}) (DeliveryServiceName, Stat, error) {
	if len(statParts) < 2 {
		return "", nil, fmt.Errorf("stat has no remap_stats deliveryservice and name parts")
	}

	fqdn := strings.Join(statParts[:len(statParts)-1], ".")
	statName := statParts[len(statParts)-1]
	ds, ok := dsRegexes.DeliveryService(fqdn)
	if !ok {
		return ds, nil, fmt.Errorf("%s matched no delivery service", fqdn)
	}

	if _, ok := dsTypes[string(ds)]; !ok {
		return ds, nil, fmt.Errorf("delivery service %s not found in types map", ds)
	}

	addedStat, err := addStat(dsStats.DeliveryService[ds], statName, value, string(ds), server, serverType, cachegroup, dsTypes)
	if err != nil {
		return ds, nil, err
	}
	return ds, addedStat, nil
}

func addStat(iStat Stat, name string, val interface{}, ds string, server string, serverType StatCacheType, cachegroup string, dsTypes map[string]StatType) (Stat, error) {
	if iStat == nil {
		return iStat, fmt.Errorf("addStat given nil stat for %s", ds)
	}

	var common *StatCommon
	common = iStat.CommonData()
	common.CachesReporting[CacheName(server)] = true
	if name == "error_string" {
		valStr, ok := val.(string)
		if !ok {
			return iStat, fmt.Errorf("stat '%s' value expected string actual '%v' type %T", name, val, val)
		}
		common.ErrorString.Value += valStr + "; " // TODO figure out what the delimiter should be
	}
	common.Status.Value = "REPORTED" // TODO fix?

	if stat, ok := iStat.(*StatHTTP); ok {
		newCachegroupStat, err := addCacheStat(stat.CacheGroups[CacheGroupName(cachegroup)], name, val)
		if err != nil {
			return stat, err
		}
		stat.CacheGroups[CacheGroupName(cachegroup)] = newCachegroupStat

		newTypeStat, err := addCacheStat(stat.Type[serverType], name, val)
		if err != nil {
			return stat, err
		}
		stat.Type[serverType] = newTypeStat

		newTotal, err := addCacheStat(stat.Total, name, val)
		if err != nil {
			return stat, err
		}
		stat.Total = newTotal
		return stat, nil
	}
	if stat, ok := iStat.(*StatDNS); ok {
		// TODO handle DNS DS stats
		return stat, nil
	}

	return iStat, fmt.Errorf("delivery service %s type is invalid", iStat)
}

// addCacheStat adds the given stat to the existing stat. Note this adds, it doesn't overwrite. Numbers are summed, strings are concatenated.
// TODO make this less duplicate code somehow.
func addCacheStat(stat StatCacheStats, name string, val interface{}) (StatCacheStats, error) {
	switch name {
	case "status_2xx":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Status2xx.Value += int64(v)
	case "status_3xx":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Status3xx.Value += int64(v)
	case "status_4xx":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Status4xx.Value += int64(v)
	case "status_5xx":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Status5xx.Value += int64(v)
	case "out_bytes":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.OutBytes.Value += int64(v)
	case "is_available":
		fmt.Println("DEBUGa got is_available")
		v, ok := val.(bool)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected bool actual '%v' type %T", name, val, val)
		}
		if v {
			stat.IsAvailable.Value = true
		}
	case "in_bytes":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.InBytes.Value += v
	case "tps_2xx":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Tps2xx.Value += v
	case "tps_3xx":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Tps3xx.Value += v
	case "tps_4xx":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Tps4xx.Value += v
	case "tps_5xx":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Tps5xx.Value += v
	case "error_string":
		v, ok := val.(string)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected string actual '%v' type %T", name, val, val)
		}
		stat.ErrorString.Value += v + ", "
	case "tps_total":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.TpsTotal.Value += v
	case "status_unknown":
		return stat, ErrNotProcessedStat
	default:
		return stat, fmt.Errorf("unknown stat '%s'", name)
	}
	return stat, nil
}

type StatName string
type StatOld struct {
	Time  int64  `json:"time"`
	Value string `json:"value"`
	Span  int    `json:"span,omitempty"`  // TODO set? remove?
	Index int    `json:"index,omitempty"` // TODO set? remove?
}
type StatsOld struct {
	DeliveryService map[DeliveryServiceName]map[StatName][]StatOld `json:"deliveryService"`
}

func addStatCacheStats(s *StatsOld, c StatCacheStats, deliveryService DeliveryServiceName, prefix string, t int64) *StatsOld {
	s.DeliveryService[deliveryService][StatName(prefix+".out_bytes")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.OutBytes.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".isAvailable")] = []StatOld{StatOld{Time: t, Value: fmt.Sprintf("%t", c.IsAvailable.Value)}}
	s.DeliveryService[deliveryService][StatName(prefix+".status_5xx")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Status5xx.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".status_4xx")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Status4xx.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".status_3xx")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Status3xx.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".status_2xx")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Status2xx.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".in_bytes")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.InBytes.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".kbps")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Kbps.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".tps_5xx")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Tps5xx.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".tps_4xx")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Tps4xx.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".tps_3xx")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Tps3xx.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".tps_2xx")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.Tps2xx.Value))}}
	s.DeliveryService[deliveryService][StatName(prefix+".error-string")] = []StatOld{StatOld{Time: t, Value: c.ErrorString.Value}}
	s.DeliveryService[deliveryService][StatName(prefix+".tps_total")] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.TpsTotal.Value))}}
	return s
}

func addCommonData(s *StatsOld, c *StatCommon, deliveryService DeliveryServiceName, t int64) *StatsOld {
	s.DeliveryService[deliveryService]["caches-configured"] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.CachesConfigured.Value))}}
	s.DeliveryService[deliveryService]["caches-reporting"] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(len(c.CachesReporting))}}
	s.DeliveryService[deliveryService]["error-string"] = []StatOld{StatOld{Time: t, Value: c.ErrorString.Value}}
	s.DeliveryService[deliveryService]["status"] = []StatOld{StatOld{Time: t, Value: c.Status.Value}}
	s.DeliveryService[deliveryService]["isHealthy"] = []StatOld{StatOld{Time: t, Value: fmt.Sprintf("%t", c.IsHealthy.Value)}}
	s.DeliveryService[deliveryService]["isAvailable"] = []StatOld{StatOld{Time: t, Value: fmt.Sprintf("%t", c.IsAvailable.Value)}}
	s.DeliveryService[deliveryService]["caches-available"] = []StatOld{StatOld{Time: t, Value: strconv.Itoa(int(c.CachesAvailable.Value))}}
	return s
}

// StatsJSON returns an object formatted as expected to be serialized to JSON and served.
func StatsJSON(dsStats Stats) StatsOld {
	now := time.Now().Unix()
	jsonObj := &StatsOld{DeliveryService: map[DeliveryServiceName]map[StatName][]StatOld{}}

	for deliveryService, dsStat := range dsStats.DeliveryService {
		jsonObj.DeliveryService[deliveryService] = map[StatName][]StatOld{}
		jsonObj = addCommonData(jsonObj, dsStat.CommonData(), deliveryService, now)
		if stat, ok := dsStat.(*StatHTTP); ok {
			for cacheGroup, cacheGroupStats := range stat.CacheGroups {
				jsonObj = addStatCacheStats(jsonObj, cacheGroupStats, deliveryService, string("location."+cacheGroup), now)
			}
			for cacheType, typeStats := range stat.Type {
				jsonObj = addStatCacheStats(jsonObj, typeStats, deliveryService, "type."+cacheType.String(), now)
			}
			jsonObj = addStatCacheStats(jsonObj, stat.Total, deliveryService, "total", now)
		}
	}
	return *jsonObj
}
