package deliveryservicestats

import (
	"errors"
	"fmt"
	"github.com/Comcast/traffic_control/traffic_monitor/experimental/traffic_monitor/cache"
	"github.com/Comcast/traffic_control/traffic_monitor/experimental/traffic_monitor/peer"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// TODO remove 'ds' and 'stat' from names

// TODO move name string types somewhere more generic

type CacheName string

type CacheGroupName string

// Current JSON endpoint:
type DeliveryServiceName string

// New, more structured format:
type DsStatMeta struct {
	Time int `json:"time"`
}
type DsStatFloat struct {
	DsStatMeta
	Value float64 `json:"value"`
}
type DsStatBool struct {
	DsStatMeta
	Value bool `json:"value"`
}
type DsStatInt struct {
	DsStatMeta
	Value int64 `json:"value"`
}
type DsStatString struct {
	DsStatMeta
	Value string `json:"value"`
}

// DsStatCacheStats is all the stats generated by a cache.
// This may also be used for aggregate stats, for example, the summary of all cache stats for a cache group, or delivery service.
// Each stat is an array, in case there are multiple data points at different times. However, a single data point i.e. a single array member is common.
type DsStatCacheStats struct {
	OutBytes    DsStatInt    `json:"out_bytes"`
	IsAvailable DsStatBool   `json:"is_available"`
	Status5xx   DsStatInt    `json:"status_5xx"`
	Status4xx   DsStatInt    `json:"status_4xx"`
	Status3xx   DsStatInt    `json:"status_3xx"`
	Status2xx   DsStatInt    `json:"status_2xx"`
	InBytes     DsStatFloat  `json:"in_bytes"`
	Kbps        DsStatFloat  `json:"kbps"`
	Tps5xx      DsStatInt    `json:"tps_5xx"`
	Tps4xx      DsStatInt    `json:"tps_4xx"`
	Tps3xx      DsStatInt    `json:"tps_3xx"`
	Tps2xx      DsStatInt    `json:"tps_2xx"`
	ErrorString DsStatString `json:"error_string"`
	TpsTotal    DsStatInt    `json:"tps_total"`
}

// TODO move and rename more generically
type DsStatCacheType string

const DsStatCacheTypeEdge = DsStatCacheType("EDGE")
const DsStatCacheTypeMid = DsStatCacheType("MID")
const DsStatCacheTypeInvalid = DsStatCacheType("INVALID")

func (t DsStatCacheType) String() string {
	switch t {
	case DsStatCacheTypeEdge:
		return "EDGE"
	case DsStatCacheTypeMid:
		return "MID"
	default:
		return "INVALID"
	}
}

func DsStatCacheTypeFromString(s string) DsStatCacheType {
	s = strings.ToLower(s)
	switch s {
	case "edge":
		return DsStatCacheTypeEdge
	case "mid":
		return DsStatCacheTypeMid
	default:
		return DsStatCacheTypeInvalid
	}
}

type DsStatType int64

const (
	DsStatTypeHTTP = iota
	DsStatTypeDNS
	DsStatTypeInvalid
)

func (t DsStatType) String() string {
	switch t {
	case DsStatTypeHTTP:
		return "HTTP"
	case DsStatTypeDNS:
		return "DNS"
	default:
		return "INVALID"
	}
}

func DsStatTypeFromString(s string) DsStatType {
	s = strings.ToLower(s)
	switch s {
	case "http":
		return DsStatTypeHTTP
	case "dns":
		return DsStatTypeDNS
	default:
		return DsStatTypeInvalid
	}
}

type DsStatCommon struct {
	CachesConfigured DsStatInt          `json:"caches_configured"`
	CachesReporting  map[CacheName]bool `json:"caches_reporting"`
	ErrorString      DsStatString       `json:"error_string"`
	Status           DsStatString       `json:"status"`
	IsHealthy        DsStatBool         `json:"is_healthy"`
	IsAvailable      DsStatBool         `json:"is_available"`
	CachesAvailable  DsStatInt          `json:"caches_available"`
}

type DsStat interface {
	DsStatType() DsStatType
	CommonData() *DsStatCommon
}

type DsStatHTTP struct {
	Common      DsStatCommon
	CacheGroups map[CacheGroupName]DsStatCacheStats
	Type        map[DsStatCacheType]DsStatCacheStats
	Total       DsStatCacheStats
}

func (d DsStatHTTP) DsStatType() DsStatType {
	return DsStatTypeHTTP
}

func (d *DsStatHTTP) CommonData() *DsStatCommon {
	return &d.Common
}

func newDsStatHTTP() *DsStatHTTP {
	return &DsStatHTTP{CacheGroups: map[CacheGroupName]DsStatCacheStats{}, Type: map[DsStatCacheType]DsStatCacheStats{}, Common: DsStatCommon{CachesReporting: map[CacheName]bool{}}}
}

type DsStatDNS struct {
	Common DsStatCommon
}

func (d DsStatDNS) DsStatType() DsStatType {
	return DsStatTypeDNS
}

func (d *DsStatDNS) CommonData() *DsStatCommon {
	return &d.Common
}

func newDsStatDNS() *DsStatDNS {
	return &DsStatDNS{Common: DsStatCommon{CachesReporting: map[CacheName]bool{}}}
}

// TODO remove DeliveryService and set type to the map directly, or add other members
type DsStats struct {
	DeliveryService map[DeliveryServiceName]DsStat `json:"deliveryService"`
}

// TODO rename to just 'New'?
func NewDsStats() DsStats {
	return DsStats{DeliveryService: map[DeliveryServiceName]DsStat{}}
}

// DsRegexes maps Delivery Service Regular Expressions to delivery services.
// For performance, we categorize Regular Expressions into 3 categories:
// 1. Direct string matches, with no regular expression matching characters
// 2. .*\.foo\..* expressions, where foo is a direct string match with no regular expression matching characters
// 3. Everything else
// This allows us to do a cheap match on 1 and 2, and only regex match the uncommon case.
// TODO performance tests, whether Go compiled *Regexp is relevantly slower than `strings.Contains` for direct and .foo. matches
type DsRegexes struct {
	DirectMatches                      map[string]DeliveryServiceName
	DotStartSlashDotFooSlashDotDotStar map[string]DeliveryServiceName
	RegexMatch                         map[*regexp.Regexp]DeliveryServiceName
}

// DeliveryService returns the delivery service which matches the given fqdn, or false.
func (d DsRegexes) DeliveryService(fqdn string) (DeliveryServiceName, bool) {
	if ds, ok := d.DirectMatches[fqdn]; ok {
		return ds, true
	}
	for matchStr, ds := range d.DotStartSlashDotFooSlashDotDotStar {
		if strings.Contains(fqdn, "."+matchStr+".") {
			return ds, true
		}
	}
	for regex, ds := range d.RegexMatch {
		if regex.MatchString(fqdn) {
			return ds, true
		}
	}
	return "", false
}

// TODO precompute; call when we get new delivery services, instead of every time we create new stats
func CreateDsRegexes(dsToRegex map[string][]string) (DsRegexes, error) {
	dsRegexes := DsRegexes{
		DirectMatches:                      map[string]DeliveryServiceName{},
		DotStartSlashDotFooSlashDotDotStar: map[string]DeliveryServiceName{},
		RegexMatch:                         map[*regexp.Regexp]DeliveryServiceName{},
	}

	for dsStr, regexStrs := range dsToRegex {
		ds := DeliveryServiceName(dsStr)
		for _, regexStr := range regexStrs {
			prefix := `.*\.`
			suffix := `\..*`
			if strings.HasPrefix(regexStr, prefix) && strings.HasSuffix(regexStr, suffix) {
				matchStr := regexStr[len(prefix) : len(regexStr)-len(suffix)]
				if otherDs, ok := dsRegexes.DotStartSlashDotFooSlashDotDotStar[matchStr]; ok {
					return dsRegexes, fmt.Errorf("duplicate regex %s (%s) in %s and %s", regexStr, matchStr, ds, otherDs)
				}
				dsRegexes.DotStartSlashDotFooSlashDotDotStar[matchStr] = ds
				continue
			}
			if !strings.ContainsAny(regexStr, `[]^\:{}()|?+*,=%@<>!'`) {
				if otherDs, ok := dsRegexes.DirectMatches[regexStr]; ok {
					return dsRegexes, fmt.Errorf("duplicate Regex %s in %s and %s", regexStr, ds, otherDs)
				}
				dsRegexes.DirectMatches[regexStr] = ds
				continue
			}
			// TODO warn? regex matches are unusual
			r, err := regexp.Compile(regexStr)
			if err != nil {
				return dsRegexes, fmt.Errorf("regex %s failed to compile: %v", regexStr, err)
			}
			dsRegexes.RegexMatch[r] = ds
		}
	}
	return dsRegexes, nil
}

func setStaticData(dsStats DsStats, dsServers map[string][]string) DsStats {
	for ds, istat := range dsStats.DeliveryService {
		istat.CommonData().CachesConfigured.Value = int64(len(dsServers[string(ds)]))
	}
	return dsStats
}

func addAvailableData(dsStats DsStats, crStates peer.Crstates, serverCachegroups map[string]string, serverDs map[string]string, serverTypes map[string]DsStatCacheType) (DsStats, error) {
	for cache, available := range crStates.Caches {
		cacheGroup, ok := serverCachegroups[cache]
		if !ok {
			fmt.Printf("WARNING: CreateDsStats not adding availability data for '%s': not found in Cachegroups\n", cache)
			continue
		}
		deliveryService, ok := serverDs[cache]
		if !ok {
			fmt.Printf("WARNING: CreateDsStats not adding availability data for '%s': not found in DeliveryServices\n", cache)
			continue
		}
		cacheType, ok := serverTypes[cache]
		if !ok {
			fmt.Printf("WARNING: CreateDsStats not adding availability data for '%s': not found in Server Types\n", cache)
			continue
		}

		iStat, ok := dsStats.DeliveryService[DeliveryServiceName(deliveryService)]
		if !ok || iStat == nil {
			fmt.Printf("WARNING: CreateDsStats not adding availability data for '%s': not found in DsStats\n", cache)
			continue // TODO log warning? Error?
		}

		if available.IsAvailable {
			iStat.CommonData().IsAvailable.Value = true
			if stat, ok := iStat.(*DsStatHTTP); ok {
				cacheGroupStats := stat.CacheGroups[CacheGroupName(cacheGroup)]
				cacheGroupStats.IsAvailable.Value = true
				stat.CacheGroups[CacheGroupName(cacheGroup)] = cacheGroupStats
				stat.Total.IsAvailable.Value = true
				typeStats := stat.Type[cacheType]
				typeStats.IsAvailable.Value = true
				stat.Type[cacheType] = typeStats
			} else if _, ok := iStat.(*DsStatDNS); ok {
			} else {
				return dsStats, fmt.Errorf("Unknown stat type for Delivery Service '%s': %v", deliveryService, iStat)
			}
		}

		dsStats.DeliveryService[DeliveryServiceName(deliveryService)] = iStat // TODO Necessary? Remove?
	}
	return dsStats, nil
}

type DsStatsLastKbps map[DeliveryServiceName]DsStatLastKbps

func NewDsStatsLastKbps() DsStatsLastKbps {
	return map[DeliveryServiceName]DsStatLastKbps{}
}

// TODO figure a way to associate this type with DsStatHTTP, with which its members correspond.
type DsStatLastKbps struct {
	CacheGroups map[CacheGroupName]LastKbpsData
	Type        map[DsStatCacheType]LastKbpsData
	Total       LastKbpsData
}

func newDsStatLastKbps() DsStatLastKbps {
	return DsStatLastKbps{CacheGroups: map[CacheGroupName]LastKbpsData{}, Type: map[DsStatCacheType]LastKbpsData{}}
}

type LastKbpsData struct {
	Kbps  float64
	Bytes int64
	Time  time.Time
}

// addKbps adds Kbps fields to the NewDsStats, based on the previous out_bytes in the oldDsStats, and the time difference.
//
// Traffic Server only updates its data every N seconds. So, often we get a new DsStats with the same OutBytes as the previous one,
// So, we must record the last changed value, and the time it changed. Then, if the new OutBytes is different from the previous,
// we set the (new - old) / lastChangedTime as the KBPS, and update the recorded LastChangedTime and LastChangedValue
//
// This specifically returns the given dsStats and lastKbpsStats on error, so it's safe to do persistentDsStats, persistentLastKbpsStats, err = addKbps(...)
func addKbps(dsStats DsStats, lastKbpsStats DsStatsLastKbps, dsStatsTime time.Time) (DsStats, DsStatsLastKbps, error) {
	for dsName, iStat := range dsStats.DeliveryService {
		if _, ok := iStat.(*DsStatDNS); ok {
			continue
		}
		if _, ok := iStat.(*DsStatHTTP); !ok {
			fmt.Printf("WARNING: addKbps got unknown stat type %T\n", iStat)
			continue
		}
		stat := iStat.(*DsStatHTTP)

		lastKbpsStat, lastKbpsStatExists := lastKbpsStats[dsName]
		if !lastKbpsStatExists {
			lastKbpsStat = newDsStatLastKbps()
		}

		for cgName, cacheStats := range stat.CacheGroups {
			lastKbpsData, _ := lastKbpsStat.CacheGroups[cgName]

			if cacheStats.OutBytes.Value == lastKbpsData.Bytes {
				cacheStats.Kbps.Value = lastKbpsData.Kbps
				stat.CacheGroups[cgName] = cacheStats
				continue
			}

			if lastKbpsStatExists {
				cacheStats.Kbps.Value = float64(cacheStats.OutBytes.Value-lastKbpsData.Bytes) / dsStatsTime.Sub(lastKbpsData.Time).Seconds()
			}

			lastKbpsStat.CacheGroups[cgName] = LastKbpsData{Time: dsStatsTime, Bytes: cacheStats.OutBytes.Value, Kbps: cacheStats.Kbps.Value}
			stat.CacheGroups[cgName] = cacheStats
		}

		for cacheType, cacheStats := range stat.Type {
			lastKbpsData, _ := lastKbpsStat.Type[cacheType]
			if cacheStats.OutBytes.Value == lastKbpsData.Bytes {
				if cacheStats.OutBytes.Value == lastKbpsData.Bytes {
					cacheStats.Kbps.Value = lastKbpsData.Kbps
					stat.Type[cacheType] = cacheStats
					continue
				}
				if lastKbpsStatExists {
					cacheStats.Kbps.Value = float64(cacheStats.OutBytes.Value-lastKbpsData.Bytes) / dsStatsTime.Sub(lastKbpsData.Time).Seconds()
				}
				lastKbpsStat.Type[cacheType] = LastKbpsData{Time: dsStatsTime, Bytes: cacheStats.OutBytes.Value, Kbps: cacheStats.Kbps.Value}
				stat.Type[cacheType] = cacheStats
			}
		}
		if lastKbpsStatExists {
			stat.Total.Kbps.Value = float64(stat.Total.OutBytes.Value-lastKbpsStat.Total.Bytes) / dsStatsTime.Sub(lastKbpsStat.Total.Time).Seconds()
		} else {
			stat.Total.Kbps.Value = lastKbpsStat.Total.Kbps
		}
		lastKbpsStat.Total = LastKbpsData{Time: dsStatsTime, Bytes: stat.Total.OutBytes.Value, Kbps: stat.Total.Kbps.Value}

		lastKbpsStats[dsName] = lastKbpsStat
	}
	return dsStats, lastKbpsStats, nil
}

func CreateDsStats(statHistory map[string][]interface{}, dsServers map[string][]string, serverDs map[string]string, dsTypes map[string]DsStatType, dsRegexStrs map[string][]string, serverCachegroups map[string]string, serverTypes map[string]DsStatCacheType, crStates peer.Crstates, lastKbpsStats DsStatsLastKbps, now time.Time) (DsStats, DsStatsLastKbps, error) {
	dsStats := NewDsStats()

	dsRegexes, err := CreateDsRegexes(dsRegexStrs)
	if err != nil {
		return DsStats{}, lastKbpsStats, fmt.Errorf("error creating DsRegexes: %v", err)
	}

	for deliveryService, _ := range dsServers {
		dsType, ok := dsTypes[deliveryService]
		if !ok {
			return DsStats{}, lastKbpsStats, fmt.Errorf("deliveryservice %s missing type", deliveryService)
		}
		if dsType == DsStatTypeHTTP {
			dsStats.DeliveryService[DeliveryServiceName(deliveryService)] = newDsStatHTTP()
		} else if dsType == DsStatTypeDNS {
			dsStats.DeliveryService[DeliveryServiceName(deliveryService)] = newDsStatDNS()
		} else {
			return DsStats{}, lastKbpsStats, fmt.Errorf("unknown type for '%s': %v", deliveryService, dsType)
		}
	}

	dsStats = setStaticData(dsStats, dsServers)
	dsStats, err = addAvailableData(dsStats, crStates, serverCachegroups, serverDs, serverTypes)
	if err != nil {
		return dsStats, lastKbpsStats, fmt.Errorf("Error getting Cache availability data: %v", err)
	}

	stats := dsStats.DeliveryService
	for server, history := range statHistory {
		cachegroup, ok := serverCachegroups[server]
		if !ok {
			fmt.Printf("WARNING server %s has no cachegroup, skipping\n", server)
			continue
		}
		serverType, ok := serverTypes[server]
		if !ok {
			fmt.Printf("WARNING server %s not in CRConfig, skipping\n", server)
			continue
		}
		for _, iresult := range history {
			result, ok := iresult.(cache.Result)
			if !ok {
				fmt.Printf("ERROR history contained unexpected result type %T\n", iresult)
				continue
			}
			for stat, value := range result.Astats.Ats {
				ds, newstat, err := processStat(&dsStats, dsRegexes, dsTypes, cachegroup, server, serverType, stat, value)
				if err == ErrNotProcessedStat {
					continue
				}
				if err != nil {
					if !strings.HasPrefix(err.Error(), "stat has unknown initial part") && !strings.HasSuffix(err.Error(), "matched no delivery service") {
						fmt.Printf("ERROR CreateDsStats failed to processStat for cachegroup '%s' server '%s' stat '%s': %v\n", cachegroup, server, stat, err)
					}
					continue
				}
				stats[ds] = newstat
			}
		}
	}
	dsStats.DeliveryService = stats
	return addKbps(dsStats, lastKbpsStats, now)
}

var ErrNotProcessedStat = errors.New("This stat is not used.")

// processStat and its subsidiary functions act as a State Machine, flowing the stat thru states for each "." component of the stat name
func processStat(dsStats *DsStats, dsRegexes DsRegexes, dsTypes map[string]DsStatType, cachegroup string, server string, serverType DsStatCacheType, stat string, value interface{}) (DeliveryServiceName, DsStat, error) {
	parts := strings.Split(stat, ".")
	if len(parts) < 1 {
		return "", nil, fmt.Errorf("stat has no initial part")
	}

	switch parts[0] {
	case "plugin":
		return processStatPlugin(dsStats, dsRegexes, dsTypes, cachegroup, server, serverType, stat, parts[1:], value)
	case "proxy":
		return "", nil, ErrNotProcessedStat
	default:
		return "", nil, fmt.Errorf("stat has unknown initial part '%s'", parts[0])
	}
}

func processStatPlugin(dsStats *DsStats, dsRegexes DsRegexes, dsTypes map[string]DsStatType, cachegroup string, server string, serverType DsStatCacheType, stat string, statParts []string, value interface{}) (DeliveryServiceName, DsStat, error) {
	if len(statParts) < 1 {
		return "", nil, fmt.Errorf("stat has no plugin part")
	}
	switch statParts[0] {
	case "remap_stats":
		return processStatPluginRemapStats(dsStats, dsRegexes, dsTypes, cachegroup, server, serverType, stat, statParts[1:], value)
	default:
		return "", nil, fmt.Errorf("stat has unknown plugin part '%s'", statParts[0])
	}
}

func processStatPluginRemapStats(dsStats *DsStats, dsRegexes DsRegexes, dsTypes map[string]DsStatType, cachegroup string, server string, serverType DsStatCacheType, stat string, statParts []string, value interface{}) (DeliveryServiceName, DsStat, error) {
	if len(statParts) < 2 {
		return "", nil, fmt.Errorf("stat has no remap_stats deliveryservice and name parts")
	}

	fqdn := strings.Join(statParts[:len(statParts)-1], ".")
	statName := statParts[len(statParts)-1]
	ds, ok := dsRegexes.DeliveryService(fqdn)
	if !ok {
		return ds, nil, fmt.Errorf("%s matched no delivery service", fqdn)
	}

	if _, ok := dsTypes[string(ds)]; !ok {
		return ds, nil, fmt.Errorf("delivery service %s not found in types map", ds)
	}

	addedStat, err := addStat(dsStats.DeliveryService[ds], statName, value, string(ds), server, serverType, cachegroup, dsTypes)
	if err != nil {
		return ds, nil, err
	}
	return ds, addedStat, nil
}

func addStat(iStat DsStat, name string, val interface{}, ds string, server string, serverType DsStatCacheType, cachegroup string, dsTypes map[string]DsStatType) (DsStat, error) {
	if iStat == nil {
		return iStat, fmt.Errorf("addStat given nil stat for %s", ds)
	}

	var common *DsStatCommon
	common = iStat.CommonData()
	common.CachesReporting[CacheName(server)] = true
	if name == "error_string" {
		valStr, ok := val.(string)
		if !ok {
			return iStat, fmt.Errorf("stat '%s' value expected string actual '%v' type %T", name, val, val)
		}
		common.ErrorString.Value += valStr + "; " // TODO figure out what the delimiter should be
	}
	common.Status.Value = "REPORTED" // TODO fix?

	if stat, ok := iStat.(*DsStatHTTP); ok {
		newCachegroupStat, err := addCacheStat(stat.CacheGroups[CacheGroupName(cachegroup)], name, val)
		if err != nil {
			return stat, err
		}
		stat.CacheGroups[CacheGroupName(cachegroup)] = newCachegroupStat

		newTypeStat, err := addCacheStat(stat.Type[serverType], name, val)
		if err != nil {
			return stat, err
		}
		stat.Type[serverType] = newTypeStat

		newTotal, err := addCacheStat(stat.Total, name, val)
		if err != nil {
			return stat, err
		}
		stat.Total = newTotal
		return stat, nil
	}
	if stat, ok := iStat.(*DsStatDNS); ok {
		// TODO handle DNS DS stats
		return stat, nil
	}

	return iStat, fmt.Errorf("delivery service %s type is invalid", iStat)
}

// addCacheStat adds the given stat to the existing stat. Note this adds, it doesn't overwrite. Numbers are summed, strings are concatenated.
func addCacheStat(stat DsStatCacheStats, name string, val interface{}) (DsStatCacheStats, error) {
	switch name {
	case "status_2xx":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Status2xx.Value += int64(v)
	case "status_3xx":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Status3xx.Value += int64(v)
	case "status_4xx":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Status4xx.Value += int64(v)
	case "status_5xx":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Status5xx.Value += int64(v)
	case "out_bytes":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.OutBytes.Value += int64(v)
	case "is_available":
		v, ok := val.(bool)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected bool actual '%v' type %T", name, val, val)
		}
		if v {
			stat.IsAvailable.Value = true
		}
	case "in_bytes":
		v, ok := val.(float64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.InBytes.Value += v
	case "tps_2xx":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Tps2xx.Value += v
	case "tps_3xx":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Tps3xx.Value += v
	case "tps_4xx":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Tps4xx.Value += v
	case "tps_5xx":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.Tps5xx.Value += v
	case "error_string":
		v, ok := val.(string)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected string actual '%v' type %T", name, val, val)
		}
		stat.ErrorString.Value += v + ", "
	case "tps_total":
		v, ok := val.(int64)
		if !ok {
			return stat, fmt.Errorf("stat '%s' value expected int actual '%v' type %T", name, val, val)
		}
		stat.TpsTotal.Value += v
	case "status_unknown":
		return stat, ErrNotProcessedStat
	default:
		return stat, fmt.Errorf("unknown stat '%s'", name)
	}
	return stat, nil
}

type DsStatName string
type DsStatOld struct {
	Time  int64  `json:"time"`
	Value string `json:"value"`
	Span  int    `json:"span,omitempty"`  // TODO set? remove?
	Index int    `json:"index,omitempty"` // TODO set? remove?
}
type DsStatsOld struct {
	DeliveryService map[DeliveryServiceName]map[DsStatName][]DsStatOld `json:"deliveryService"`
}

func addDsStatCacheStats(s *DsStatsOld, c DsStatCacheStats, deliveryService DeliveryServiceName, prefix string, t int64) *DsStatsOld {
	s.DeliveryService[deliveryService][DsStatName(prefix+".out_bytes")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.OutBytes.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".isAvailable")] = []DsStatOld{DsStatOld{Time: t, Value: fmt.Sprintf("%t", c.IsAvailable.Value)}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".status_5xx")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Status5xx.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".status_4xx")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Status4xx.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".status_3xx")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Status3xx.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".status_2xx")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Status2xx.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".in_bytes")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.InBytes.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".kbps")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Kbps.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".tps_5xx")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Tps5xx.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".tps_4xx")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Tps4xx.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".tps_3xx")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Tps3xx.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".tps_2xx")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.Tps2xx.Value))}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".error-string")] = []DsStatOld{DsStatOld{Time: t, Value: c.ErrorString.Value}}
	s.DeliveryService[deliveryService][DsStatName(prefix+".tps_total")] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.TpsTotal.Value))}}
	return s
}

func addCommonData(s *DsStatsOld, c *DsStatCommon, deliveryService DeliveryServiceName, t int64) *DsStatsOld {
	s.DeliveryService[deliveryService]["caches-configured"] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.CachesConfigured.Value))}}
	s.DeliveryService[deliveryService]["caches-reporting"] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(len(c.CachesReporting))}}
	s.DeliveryService[deliveryService]["error-string"] = []DsStatOld{DsStatOld{Time: t, Value: c.ErrorString.Value}}
	s.DeliveryService[deliveryService]["status"] = []DsStatOld{DsStatOld{Time: t, Value: c.Status.Value}}
	s.DeliveryService[deliveryService]["isHealthy"] = []DsStatOld{DsStatOld{Time: t, Value: fmt.Sprintf("%t", c.IsHealthy.Value)}}
	s.DeliveryService[deliveryService]["isAvailable"] = []DsStatOld{DsStatOld{Time: t, Value: fmt.Sprintf("%t", c.IsAvailable.Value)}}
	s.DeliveryService[deliveryService]["caches-available"] = []DsStatOld{DsStatOld{Time: t, Value: strconv.Itoa(int(c.CachesAvailable.Value))}}
	return s
}

// DsStatsJSON returns an object formatted as expected to be serialized to JSON and served.
func DsStatsJSON(dsStats DsStats) DsStatsOld {
	now := time.Now().Unix()
	jsonObj := &DsStatsOld{DeliveryService: map[DeliveryServiceName]map[DsStatName][]DsStatOld{}}

	for deliveryService, dsStat := range dsStats.DeliveryService {
		jsonObj.DeliveryService[deliveryService] = map[DsStatName][]DsStatOld{}
		jsonObj = addCommonData(jsonObj, dsStat.CommonData(), deliveryService, now)
		if stat, ok := dsStat.(*DsStatHTTP); ok {
			for cacheGroup, cacheGroupStats := range stat.CacheGroups {
				jsonObj = addDsStatCacheStats(jsonObj, cacheGroupStats, deliveryService, string("location."+cacheGroup), now)
			}
			for cacheType, typeStats := range stat.Type {
				jsonObj = addDsStatCacheStats(jsonObj, typeStats, deliveryService, "type."+cacheType.String(), now)
			}
			jsonObj = addDsStatCacheStats(jsonObj, stat.Total, deliveryService, "total", now)
		}
	}
	return *jsonObj
}
