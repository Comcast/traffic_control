diff --git a/build/ax_cxx_compile_stdcxx_11.m4 b/build/ax_cxx_compile_stdcxx_11.m4
index e4ba5f5..a8b7d52 100644
--- a/build/ax_cxx_compile_stdcxx_11.m4
+++ b/build/ax_cxx_compile_stdcxx_11.m4
@@ -4,69 +4,57 @@
 #
 # SYNOPSIS
 #
-#   AX_CXX_COMPILE_STDCXX_11([ext|noext],[action-if-success],[action-if-failure])
+#   AX_CXX_COMPILE_STDCXX_11([ext|noext],[mandatory|optional])
 #
 # DESCRIPTION
 #
 #   Check for baseline language coverage in the compiler for the C++11
 #   standard; if necessary, add switches to CXXFLAGS to enable support.
-#   Errors out if no mode that supports C++11 baseline syntax can be found.
-#   The argument, if specified, indicates whether you insist on an extended
-#   mode (e.g. -std=gnu++11) or a strict conformance mode (e.g. -std=c++11).
-#   If neither is specified, you get whatever works, with preference for an
-#   extended mode.
+#
+#   The first argument, if specified, indicates whether you insist on an
+#   extended mode (e.g. -std=gnu++11) or a strict conformance mode (e.g.
+#   -std=c++11).  If neither is specified, you get whatever works, with
+#   preference for an extended mode.
+#
+#   The second argument, if specified 'mandatory' or if left unspecified,
+#   indicates that baseline C++11 support is required and that the macro
+#   should error out if no mode with that support is found.  If specified
+#   'optional', then configuration proceeds regardless, after defining
+#   HAVE_CXX11 if and only if a supporting mode is found.
 #
 # LICENSE
 #
 #   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>
 #   Copyright (c) 2012 Zack Weinberg <zackw@panix.com>
+#   Copyright (c) 2013 Roy Stogner <roystgnr@ices.utexas.edu>
+#   Copyright (c) 2014, 2015 Google Inc.; contributed by Alexey Sokolov <sokolov@google.com>
 #
 #   Copying and distribution of this file, with or without modification, are
 #   permitted in any medium without royalty provided the copyright notice
 #   and this notice are preserved. This file is offered as-is, without any
 #   warranty.
 
-#serial 1
-
-m4_define([_AX_CXX_COMPILE_STDCXX_11_testbody], [
-  template <typename T>
-    struct check
-    {
-      static_assert(sizeof(int) <= sizeof(T), "not big enough");
-    };
-
-
-    struct in_class_initialization {
-      int i = 0;
-    };
-
-    typedef check<check<bool>> right_angle_brackets;
-
-    int a;
-    decltype(a) b;
+#serial 11
 
-    typedef check<int> check_type;
-    check_type c;
-    check_type&& cr = static_cast<check_type&&>(c);
-
-    void * null_pointer_keyword = nullptr;
-])
+# ATS: Modified to simply check for unordered map, which is the main
+# feature we need right now from C++0x
+m4_define([_AX_CXX_COMPILE_STDCXX_11_testbody], [[
+    #include <unordered_map>
+]])
 
 AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [dnl
   m4_if([$1], [], [],
         [$1], [ext], [],
         [$1], [noext], [],
         [m4_fatal([invalid argument `$1' to AX_CXX_COMPILE_STDCXX_11])])dnl
-  AC_LANG_ASSERT([C++])dnl
+  m4_if([$2], [], [ax_cxx_compile_cxx11_required=true],
+        [$2], [mandatory], [ax_cxx_compile_cxx11_required=true],
+        [$2], [optional], [ax_cxx_compile_cxx11_required=false],
+        [m4_fatal([invalid second argument `$2' to AX_CXX_COMPILE_STDCXX_11])])
+  AC_LANG_PUSH([C++])dnl
+
+# We now require either -std=c++11 or -std=c++0x, so don't test without either
   ac_success=no
-  AC_CACHE_CHECK(whether $CXX supports C++11 features by default,
-  ax_cv_cxx_compile_cxx11,
-  [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_11_testbody])],
-    [ax_cv_cxx_compile_cxx11=yes],
-    [ax_cv_cxx_compile_cxx11=no])])
-  if test x$ax_cv_cxx_compile_cxx11 = xyes; then
-    ac_success=yes
-  fi
 
   m4_if([$1], [noext], [], [dnl
   if test x$ac_success = xno; then
@@ -90,7 +78,9 @@ AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [dnl
 
   m4_if([$1], [ext], [], [dnl
   if test x$ac_success = xno; then
-    for switch in -std=c++11 -std=c++0x; do
+    dnl HP's aCC needs +std=c++11 according to:
+    dnl http://h21007.www2.hp.com/portal/download/files/unprot/aCxx/PDF_Release_Notes/769149-001.pdf
+    for switch in -std=c++11 -std=c++0x +std=c++11; do
       cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx11_$switch])
       AC_CACHE_CHECK(whether $CXX supports C++11 features with $switch,
                      $cachevar,
@@ -107,10 +97,21 @@ AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [dnl
       fi
     done
   fi])
-
-  if test x$ac_success = xno ; then
-    m4_if([$3], [], [true], [$3])
+  AC_LANG_POP([C++])
+  if test x$ax_cxx_compile_cxx11_required = xtrue; then
+    if test x$ac_success = xno; then
+      AC_MSG_ERROR([*** A compiler with support for C++11 language features is required.])
+    fi
   else
-    m4_if([$2], [], [true], [$2])
+    if test x$ac_success = xno; then
+      HAVE_CXX11=0
+      AC_MSG_NOTICE([No compiler with C++11 support was found])
+    else
+      HAVE_CXX11=1
+      AC_DEFINE(HAVE_CXX11,1,
+                [define if the compiler supports basic C++11 syntax])
+    fi
+
+    AC_SUBST(HAVE_CXX11)
   fi
 ])
diff --git a/cmd/traffic_top/stats.h b/cmd/traffic_top/stats.h
index 4b48bde..9fc8ac8 100644
--- a/cmd/traffic_top/stats.h
+++ b/cmd/traffic_top/stats.h
@@ -385,8 +385,8 @@ public:
         value = (value - old) / _time_diff;
       }
     } else if (type == 3 || type == 4) {
-      double numerator;
-      double denominator;
+      double numerator = 0;
+      double denominator = 0;
       getStat(item.numerator, numerator);
       getStat(item.denominator, denominator);
       if (denominator == 0)
diff --git a/configure.ac b/configure.ac
index 45c47fe..2c79ca4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -578,10 +578,7 @@ CXXFLAGS="${_ts_saved_CXXFLAGS}"
 # AX_CXX_COMPILE_STDCXX_11 requires the current language to be C++.
 AC_LANG_PUSH([C++])
 
-AX_CXX_COMPILE_STDCXX_11( [noext], [enable_cxx_11_support=yes], [
-  enable_cxx_11_support=no
-  AC_MSG_NOTICE([disabling features that depend on C++11 support])
-])
+AX_CXX_COMPILE_STDCXX_11( [noext], [mandatory])
 
 AM_CONDITIONAL([BUILD_HAVE_CXX_11], [ test "x${enable_cxx_11_support}" = "xyes" ])
 if test "x${enable_cxx_11_support}" = "xyes" ; then
@@ -1948,6 +1945,7 @@ AS_IF([test "x$enable_experimental_plugins" = xyes], [
     plugins/experimental/background_fetch/Makefile
     plugins/experimental/balancer/Makefile
     plugins/experimental/buffer_upload/Makefile
+    plugins/experimental/cache_promote/Makefile
     plugins/experimental/cache_range_requests/Makefile
     plugins/experimental/channel_stats/Makefile
     plugins/experimental/collapsed_connection/Makefile
@@ -1968,6 +1966,7 @@ AS_IF([test "x$enable_experimental_plugins" = xyes], [
     plugins/experimental/ssl_cert_loader/Makefile
     plugins/experimental/sslheaders/Makefile
     plugins/experimental/stale_while_revalidate/Makefile
+    plugins/experimental/stream_editor/Makefile
     plugins/experimental/ts_lua/Makefile
     plugins/experimental/url_sig/Makefile
     plugins/experimental/xdebug/Makefile
diff --git a/doc/reference/configuration/parent.config.en.rst b/doc/reference/configuration/parent.config.en.rst
index f025a7a..88166c9 100644
--- a/doc/reference/configuration/parent.config.en.rst
+++ b/doc/reference/configuration/parent.config.en.rst
@@ -21,11 +21,12 @@ parent.config
 
 .. configfile:: parent.config
 
-The :file:`parent.config` file identifies the parent proxies used in an
-cache hierarchy. Use this file to perform the following configuration:
+The :file:`parent.config` file identifies the parent proxies or origins 
+used in an cache hierarchy. Use this file to perform the following configuration:
 
 -  Set up parent cache hierarchies, with multiple parents and parent
    failover
+-  Configure multiple parent origin servers.
 -  Configure selected URL requests to bypass parent proxies
 
 Traffic Server uses the :file:`parent.config` file only when the parent
@@ -122,6 +123,17 @@ The following list shows the possible actions and their allowed values.
     origin server. You can specify either a hostname or an IP address,
     but; you must specify the port number.
 
+.. _parent-config-format-secondary_parent-parent:
+
+``secondary_parent``
+    An optional ordered list of secondary parent servers using the same format
+    as the ``parent`` list.  A ``secondary_parent`` list only applies
+    when ``round_robin`` is set to ``consistent_hash``.  When using
+    ``consistent_hash``, if the server chosen from the primary list fails,
+    a parent is selected from a secondary consistent hash ring. This feature
+    works best in a multi-tiered cache hierarchy where one might take advantage
+    of the content affinint built up on a secondary list of parents.
+
 .. _parent-config-format-round-robin:
 
 ``round_robin``
@@ -135,6 +147,21 @@ The following list shows the possible actions and their allowed values.
     -  ``false`` - Round robin selection does not occur.
     -  ``consistent_hash`` - consistent hash.
 
+.. _parent-config-format-parent_is_proxy:
+
+``parent_is_proxy``
+    One of the following values:
+
+    - ``true`` - Specifies that the parents are ATS cache proxies, within
+                 a hierarchy.  This is the default value, if ``parent_is_proxy``
+                 is not specified in the configuration.
+
+    - ``false`` - Specifies that the parents are origin servers. The request
+                  url's are modified so they are appropriate for origin
+                  requests.  Normal Parent Selection behaviour applies to
+                  the origins listed.  Since these would be a list of origin
+                  servers, set go_direct described below to ``false``.
+
 .. _parent-config-format-go-direct:
 
 ``go_direct``
diff --git a/doc/reference/configuration/records.config.en.rst b/doc/reference/configuration/records.config.en.rst
index d23b864..e7ea6ba 100644
--- a/doc/reference/configuration/records.config.en.rst
+++ b/doc/reference/configuration/records.config.en.rst
@@ -929,6 +929,26 @@ Parent Proxy Configuration
 
    Don't try to resolve DNS, forward all DNS requests to the parent. This is off (``0``) by default.
 
+.. ts:cv:: CONFIG proxy.config.http.parent_origin.simple_retry_enabled INT 0
+
+   Enable the simple retry feature, This is off (``0``) by default.  simple retry is only used for 
+   parent origin servers, see configuration information for parent.config. 
+
+.. ts:cv:: CONFIG proxy.config.http.parent_origin.simple_retry_response_codes STRING 0
+
+   This is a comma separated list of response codes that will trigger a simple retry on a parent
+   origin server if ``simple_retry`` above is enabled.  This is a ``404`` by default.
+
+.. ts:cv:: CONFIG proxy.config.http.parent_origin.dead_server_retry_enabled INT 0
+
+   Enable the dead_server retry feature, This is off (``0``) by default.  dead server retry 
+   is only used for parent origin servers, see configuration information for parent.config. 
+
+.. ts:cv:: CONFIG proxy.config.http.parent_origin.dead_server_retry_response_codes STRING 0
+
+   This is a comma separated list of response codes that will trigger a dead server retry on 
+   a parent origin server if ``dead_server_retry`` above is enabled.  This is a ``503`` by default.
+
 HTTP Connection Timeouts
 ========================
 
diff --git a/iocore/cache/CacheDir.cc b/iocore/cache/CacheDir.cc
index e54fbfb..30f46cd 100644
--- a/iocore/cache/CacheDir.cc
+++ b/iocore/cache/CacheDir.cc
@@ -1140,6 +1140,15 @@ CacheSync::mainEvent(int event, Event *e)
 Lrestart:
   if (vol_idx >= gnvol) {
     vol_idx = 0;
+    if (buf) {
+      if (buf_huge)
+        ats_free_hugepage(buf, buflen);
+      else
+        ats_memalign_free(buf);
+      buflen = 0;
+      buf = NULL;
+      buf_huge = false;
+    }
     Debug("cache_dir_sync", "sync done");
     if (event == EVENT_INTERVAL)
       trigger = e->ethread->schedule_in(this, HRTIME_SECONDS(cache_config_dir_sync_frequency));
diff --git a/iocore/eventsystem/UnixEventProcessor.cc b/iocore/eventsystem/UnixEventProcessor.cc
index 54fec71..c3180fa 100644
--- a/iocore/eventsystem/UnixEventProcessor.cc
+++ b/iocore/eventsystem/UnixEventProcessor.cc
@@ -135,10 +135,14 @@ EventProcessor::start(int n_event_threads, size_t stacksize)
   Debug("iocore_thread", "Affinity: %d %ss: %d PU: %d", affinity, obj_name, obj_count, ink_number_of_processors());
 
 #endif
-  for (i = first_thread; i < n_ethreads; i++) {
-    snprintf(thr_name, MAX_THREAD_NAME_LENGTH, "[ET_NET %d]", i);
-    ink_thread tid = all_ethreads[i]->start(thr_name, stacksize);
-    (void)tid;
+  for (i = 0; i < n_ethreads; i++) {
+    ink_thread tid;
+    if (i >= first_thread) {
+      snprintf(thr_name, MAX_THREAD_NAME_LENGTH, "[ET_NET %d]", i);
+      tid = all_ethreads[i]->start(thr_name, stacksize);
+    } else {
+      tid = ink_thread_self();
+    }
 #if TS_USE_HWLOC
     if (obj_count > 0) {
       obj = hwloc_get_obj_by_type(ink_get_topology(), obj_type, i % obj_count);
@@ -154,6 +158,8 @@ EventProcessor::start(int n_event_threads, size_t stacksize)
     } else {
       Warning("hwloc returned an unexpected value -- CPU affinity disabled");
     }
+#else
+    (void)tid;
 #endif // TS_USE_HWLOC
   }
 
diff --git a/iocore/net/SSLSessionCache.cc b/iocore/net/SSLSessionCache.cc
index 740b14f..67513a1 100644
--- a/iocore/net/SSLSessionCache.cc
+++ b/iocore/net/SSLSessionCache.cc
@@ -22,7 +22,6 @@
 #include "P_SSLConfig.h"
 #include "SSLSessionCache.h"
 #include <cstring>
-#include <memory>
 
 #define SSLSESSIONCACHE_STRINGIFY0(x) #x
 #define SSLSESSIONCACHE_STRINGIFY(x) SSLSESSIONCACHE_STRINGIFY0(x)
@@ -132,7 +131,7 @@ SSLSessionBucket::insertSession(const SSLSessionID &id, SSL_SESSION *sess)
   unsigned char *loc = reinterpret_cast<unsigned char *>(buf->data());
   i2d_SSL_SESSION(sess, &loc);
 
-  std::auto_ptr<SSLSession> ssl_session(new SSLSession(id, buf, len));
+  ats_scoped_obj<SSLSession> ssl_session(new SSLSession(id, buf, len));
 
   MUTEX_TRY_LOCK(lock, mutex, this_ethread());
   if (!lock.is_locked()) {
diff --git a/iocore/net/Socks.cc b/iocore/net/Socks.cc
index a0350f6..7af322f 100644
--- a/iocore/net/Socks.cc
+++ b/iocore/net/Socks.cc
@@ -146,7 +146,7 @@ SocksEntry::free()
 
 #ifdef SOCKS_WITH_TS
   if (!lerrno && netVConnection && server_result.retry)
-    server_params->recordRetrySuccess(&server_result);
+    server_params->markParentUp(&server_result);
 #endif
 
   if ((action_.cancelled || lerrno) && netVConnection)
diff --git a/lib/records/RecProcess.cc b/lib/records/RecProcess.cc
index 9a44ee6..1b69b0c 100644
--- a/lib/records/RecProcess.cc
+++ b/lib/records/RecProcess.cc
@@ -562,11 +562,6 @@ _RecRegisterRawStat(RecRawStatBlock *rsb, RecT rec_type, const char *name, RecDa
     err = REC_ERR_FAIL;
     goto Ldone;
   }
-  if (r->rsb_id > 0 && r->rsb_id != id) {
-    Warning("_RecRegisterRawStat(): Created and reusing a stat with id = %d for new stat named %s", r->rsb_id, name);
-  } else {
-    Warning("_RecRegisterStat(): Stat created, name: %s, id: %d", name, id);
-  }
   r->rsb_id = id; // This is the index within the RSB raw block for this stat, used for lookups by name.
   if (i_am_the_record_owner(r->rec_type)) {
     r->sync_required = r->sync_required | REC_PEER_SYNC_REQUIRED;
@@ -581,7 +576,6 @@ _RecRegisterRawStat(RecRawStatBlock *rsb, RecT rec_type, const char *name, RecDa
 
   // setup the periodic sync callback
   RecRegisterRawStatSyncCb(name, sync_cb, rsb, id);
-  Warning("_RecRegisterRawStat(): Stat created, id:%d name:%s, data address:%p", id, name, &r->stat_meta.data_raw);
 
 Ldone:
   return err;
diff --git a/lib/ts/ConsistentHash.cc b/lib/ts/ConsistentHash.cc
index 912bc74..22f12c0 100644
--- a/lib/ts/ConsistentHash.cc
+++ b/lib/ts/ConsistentHash.cc
@@ -67,19 +67,13 @@ ATSConsistentHash::insert(ATSConsistentHashNode *node, float weight, ATSHash64 *
 }
 
 ATSConsistentHashNode *
-ATSConsistentHash::lookup(const char *url, size_t url_len, ATSConsistentHashIter *i, bool *w, ATSHash64 *h)
+ATSConsistentHash::lookup(const char *url, ATSConsistentHashIter *i, bool *w, ATSHash64 *h)
 {
   uint64_t url_hash;
   ATSConsistentHashIter NodeMapIterUp, *iter;
   ATSHash64 *thash;
   bool *wptr, wrapped = false;
 
-  if (url_len <= 0 && url) {
-    url_len = strlen(url);
-  } else {
-    url_len = 0;
-  }
-
   if (h) {
     thash = h;
   } else if (hash) {
@@ -101,7 +95,7 @@ ATSConsistentHash::lookup(const char *url, size_t url_len, ATSConsistentHashIter
   }
 
   if (url) {
-    thash->update(url, url_len);
+    thash->update(url, strlen(url));
     thash->final();
     url_hash = thash->get();
     thash->clear();
@@ -130,19 +124,13 @@ ATSConsistentHash::lookup(const char *url, size_t url_len, ATSConsistentHashIter
 }
 
 ATSConsistentHashNode *
-ATSConsistentHash::lookup_available(const char *url, size_t url_len, ATSConsistentHashIter *i, bool *w, ATSHash64 *h)
+ATSConsistentHash::lookup_available(const char *url, ATSConsistentHashIter *i, bool *w, ATSHash64 *h)
 {
   uint64_t url_hash;
   ATSConsistentHashIter NodeMapIterUp, *iter;
   ATSHash64 *thash;
   bool *wptr, wrapped = false;
 
-  if (url_len <= 0 && url) {
-    url_len = strlen(url);
-  } else {
-    url_len = 0;
-  }
-
   if (h) {
     thash = h;
   } else if (hash) {
@@ -164,7 +152,7 @@ ATSConsistentHash::lookup_available(const char *url, size_t url_len, ATSConsiste
   }
 
   if (url) {
-    thash->update(url, url_len);
+    thash->update(url, strlen(url));
     thash->final();
     url_hash = thash->get();
     thash->clear();
diff --git a/lib/ts/ConsistentHash.h b/lib/ts/ConsistentHash.h
index 49822ad..dbfd6c3 100644
--- a/lib/ts/ConsistentHash.h
+++ b/lib/ts/ConsistentHash.h
@@ -49,10 +49,9 @@ typedef std::map<uint64_t, ATSConsistentHashNode *>::iterator ATSConsistentHashI
 struct ATSConsistentHash {
   ATSConsistentHash(int r = 1024, ATSHash64 *h = NULL);
   void insert(ATSConsistentHashNode *node, float weight = 1.0, ATSHash64 *h = NULL);
-  ATSConsistentHashNode *lookup(const char *url = NULL, size_t url_len = 0, ATSConsistentHashIter *i = NULL, bool *w = NULL,
-                                ATSHash64 *h = NULL);
-  ATSConsistentHashNode *lookup_available(const char *url = NULL, size_t url_len = 0, ATSConsistentHashIter *i = NULL,
-                                          bool *w = NULL, ATSHash64 *h = NULL);
+  ATSConsistentHashNode *lookup(const char *url = NULL, ATSConsistentHashIter *i = NULL, bool *w = NULL, ATSHash64 *h = NULL);
+  ATSConsistentHashNode *lookup_available(const char *url = NULL, ATSConsistentHashIter *i = NULL, bool *w = NULL,
+                                          ATSHash64 *h = NULL);
   ATSConsistentHashNode *lookup_by_hashval(uint64_t hashval, ATSConsistentHashIter *i = NULL, bool *w = NULL);
   ~ATSConsistentHash();
 
diff --git a/lib/ts/ink_memory.cc b/lib/ts/ink_memory.cc
index 4c18c43..aba2104 100644
--- a/lib/ts/ink_memory.cc
+++ b/lib/ts/ink_memory.cc
@@ -187,22 +187,10 @@ ats_msync(caddr_t addr, size_t len, caddr_t end, int flags)
 int
 ats_madvise(caddr_t addr, size_t len, int flags)
 {
-#if defined(linux)
-  (void)addr;
-  (void)len;
-  (void)flags;
-  return 0;
-#else
-  size_t pagesize = ats_pagesize();
-  caddr_t a = (caddr_t)(((uintptr_t)addr) & ~(pagesize - 1));
-  size_t l = (len + (addr - a) + pagesize - 1) & ~(pagesize - 1);
-  int res = 0;
 #if HAVE_POSIX_MADVISE
-  res = posix_madvise(a, l, flags);
+  return posix_madvise(addr, len, flags);
 #else
-  res = madvise(a, l, flags);
-#endif
-  return res;
+  return madvise(addr, len, flags);
 #endif
 }
 
diff --git a/lib/ts/ink_queue.cc b/lib/ts/ink_queue.cc
index 0f14b68..da2a93d 100644
--- a/lib/ts/ink_queue.cc
+++ b/lib/ts/ink_queue.cc
@@ -106,7 +106,7 @@ ink_freelist_init(InkFreeList **fl, const char *name, uint32_t type_size, uint32
   if (ats_hugepage_enabled()) {
     f->chunk_size = INK_ALIGN(chunk_size * f->type_size, ats_hugepage_size()) / f->type_size;
   } else {
-    f->chunk_size = chunk_size;
+    f->chunk_size = INK_ALIGN(chunk_size * f->type_size, ats_pagesize()) / f->type_size;
   }
   SET_FREELIST_POINTER_VERSION(f->head, FROM_PTR(0), 0);
 
@@ -163,6 +163,7 @@ ink_freelist_new(InkFreeList *f)
     if (TO_PTR(FREELIST_POINTER(item)) == NULL) {
       uint32_t type_size = f->type_size;
       uint32_t i;
+      size_t alloc_size = 0;
 
 #ifdef MEMPROTECT
       if (type_size >= MEMPROTECT_SIZE) {
@@ -176,16 +177,17 @@ ink_freelist_new(InkFreeList *f)
 #ifdef DEBUG
       char *oldsbrk = (char *)sbrk(0), *newsbrk = NULL;
 #endif
-      if (ats_hugepage_enabled())
-        newp = ats_alloc_hugepage(f->chunk_size * type_size);
+      if (ats_hugepage_enabled()) {
+        alloc_size = INK_ALIGN(f->chunk_size * f->type_size, ats_hugepage_size());
+        newp = ats_alloc_hugepage(alloc_size);
+      }
 
       if (newp == NULL) {
-        if (f->alignment)
-          newp = ats_memalign(f->alignment, f->chunk_size * type_size);
-        else
-          newp = ats_malloc(f->chunk_size * type_size);
+        alloc_size = INK_ALIGN(f->chunk_size * f->type_size, ats_pagesize());
+        newp = ats_memalign(ats_pagesize(), alloc_size);
       }
-      ats_madvise((caddr_t)newp, f->chunk_size * type_size, f->advice);
+
+      ats_madvise((caddr_t)newp, alloc_size, f->advice);
       fl_memadd(f->chunk_size * type_size);
 #ifdef DEBUG
       newsbrk = (char *)sbrk(0);
@@ -238,7 +240,6 @@ ink_freelist_new(InkFreeList *f)
 #endif /* SANITY */
     }
   } while (result == 0);
-  ink_assert(!((uintptr_t)TO_PTR(FREELIST_POINTER(item)) & (((uintptr_t)f->alignment) - 1)));
 
   ink_atomic_increment((int *)&f->used, 1);
   ink_atomic_increment(&fastalloc_mem_in_use, (int64_t)f->type_size);
@@ -252,7 +253,7 @@ ink_freelist_new(InkFreeList *f)
     newp = ats_memalign(f->alignment, f->type_size);
   else
     newp = ats_malloc(f->type_size);
-  ats_madvise((caddr_t)newp, f->type_size, f->advice);
+
   return newp;
 #endif
 }
diff --git a/lib/tsconfig/TsConfigGrammar.c b/lib/tsconfig/TsConfigGrammar.c
index c63b4d8..042a146 100644
--- a/lib/tsconfig/TsConfigGrammar.c
+++ b/lib/tsconfig/TsConfigGrammar.c
@@ -1,19 +1,21 @@
-/* A Bison parser, made by GNU Bison 2.7.  */
 
-/* Bison implementation for Yacc-like parsers in C
-
-      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
+/* A Bison parser, made by GNU Bison 2.4.1.  */
 
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
-
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
@@ -26,7 +28,7 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
@@ -44,7 +46,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.7"
+#define YYBISON_VERSION "2.4.1"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -58,8 +60,12 @@
 /* Pull parsers.  */
 #define YYPULL 1
 
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
 /* "%code top" blocks.  */
-/* Line 349 of yacc.c  */
+
+/* Line 171 of yacc.c  */
 #line 26 "TsConfigGrammar.y"
 
 # if ! (defined(__clang_analyzer__) || defined(__COVERITY__))
@@ -79,9 +85,9 @@ extern int tsconfiglex(YYSTYPE* yylval, yyscan_t lexer);
 
 
 
-/* Line 349 of yacc.c  */
-#line 84 "TsConfigGrammar.c"
 
+/* Line 171 of yacc.c  */
+#line 91 "TsConfigGrammar.c"
 /* Substitute the variable and function names.  */
 #define yyparse         tsconfigparse
 #define yylex           tsconfiglex
@@ -91,18 +97,17 @@ extern int tsconfiglex(YYSTYPE* yylval, yyscan_t lexer);
 #define yydebug         tsconfigdebug
 #define yynerrs         tsconfignerrs
 
+
 /* Copy the first part of user declarations.  */
 
-/* Line 371 of yacc.c  */
-#line 98 "TsConfigGrammar.c"
 
-# ifndef YY_NULL
-#  if defined __cplusplus && 201103L <= __cplusplus
-#   define YY_NULL nullptr
-#  else
-#   define YY_NULL 0
-#  endif
-# endif
+/* Line 189 of yacc.c  */
+#line 106 "TsConfigGrammar.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
 
 /* Enabling verbose error messages.  */
 #ifdef YYERROR_VERBOSE
@@ -112,19 +117,14 @@ extern int tsconfiglex(YYSTYPE* yylval, yyscan_t lexer);
 # define YYERROR_VERBOSE 1
 #endif
 
-/* In a future release of Bison, this section will be replaced
-   by #include "y.tab.h".  */
-#ifndef YY_TSCONFIG_TSCONFIGGRAMMAR_H_INCLUDED
-# define YY_TSCONFIG_TSCONFIGGRAMMAR_H_INCLUDED
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int tsconfigdebug;
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
 #endif
+
 /* "%code requires" blocks.  */
-/* Line 387 of yacc.c  */
+
+/* Line 209 of yacc.c  */
 #line 1 "TsConfigGrammar.y"
 
 /** @file
@@ -151,8 +151,9 @@ extern int tsconfigdebug;
  */
 
 
-/* Line 387 of yacc.c  */
-#line 156 "TsConfigGrammar.c"
+
+/* Line 209 of yacc.c  */
+#line 157 "TsConfigGrammar.c"
 
 /* Tokens.  */
 #ifndef YYTOKENTYPE
@@ -190,6 +191,7 @@ extern int tsconfigdebug;
 
 
 
+
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef int YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
@@ -198,28 +200,14 @@ typedef int YYSTYPE;
 #endif
 
 
-#ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
-int tsconfigparse (void *YYPARSE_PARAM);
-#else
-int tsconfigparse ();
-#endif
-#else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
-int tsconfigparse (yyscan_t lexer, struct TsConfigHandlers* handlers);
-#else
-int tsconfigparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-#endif /* !YY_TSCONFIG_TSCONFIGGRAMMAR_H_INCLUDED  */
-
 /* Copy the second part of user declarations.  */
 
-/* Line 390 of yacc.c  */
-#line 221 "TsConfigGrammar.c"
+
+/* Line 264 of yacc.c  */
+#line 208 "TsConfigGrammar.c"
 /* Unqualified %code blocks.  */
-/* Line 391 of yacc.c  */
+
+/* Line 265 of yacc.c  */
 #line 44 "TsConfigGrammar.y"
 
 
@@ -242,8 +230,9 @@ int tsconfigerror(
 
 
 
-/* Line 391 of yacc.c  */
-#line 247 "TsConfigGrammar.c"
+
+/* Line 265 of yacc.c  */
+#line 236 "TsConfigGrammar.c"
 
 #ifdef short
 # undef short
@@ -293,27 +282,27 @@ typedef short int yytype_int16;
 #define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
 
 #ifndef YY_
-# if defined YYENABLE_NLS && YYENABLE_NLS
+# if YYENABLE_NLS
 #  if ENABLE_NLS
 #   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
 #  endif
 # endif
 # ifndef YY_
-#  define YY_(Msgid) Msgid
+#  define YY_(msgid) msgid
 # endif
 #endif
 
 /* Suppress unused-variable warnings by "using" E.  */
 #if ! defined lint || defined __GNUC__
-# define YYUSE(E) ((void) (E))
+# define YYUSE(e) ((void) (e))
 #else
-# define YYUSE(E) /* empty */
+# define YYUSE(e) /* empty */
 #endif
 
 /* Identity function, used to suppress warnings about constant conditions.  */
 #ifndef lint
-# define YYID(N) (N)
+# define YYID(n) (n)
 #else
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
@@ -346,12 +335,11 @@ YYID (yyi)
 #    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
 #     endif
 #    endif
 #   endif
@@ -374,24 +362,24 @@ YYID (yyi)
 #  ifndef YYSTACK_ALLOC_MAXIMUM
 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+#  if (defined __cplusplus && ! defined _STDLIB_H \
        && ! ((defined YYMALLOC || defined malloc) \
 	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
 #   endif
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
@@ -420,7 +408,23 @@ union yyalloc
      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
-# define YYCOPY_NEEDED 1
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
 
 /* Relocate STACK from its old location to the new one.  The
    local variables YYSIZE and YYSTACKSIZE give the old and new number of
@@ -440,26 +444,6 @@ union yyalloc
 
 #endif
 
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
-/* Copy COUNT objects from SRC to DST.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
-#  else
-#   define YYCOPY(Dst, Src, Count)              \
-      do                                        \
-        {                                       \
-          YYSIZE_T yyi;                         \
-          for (yyi = 0; yyi < (Count); yyi++)   \
-            (Dst)[yyi] = (Src)[yyi];            \
-        }                                       \
-      while (YYID (0))
-#  endif
-# endif
-#endif /* !YYCOPY_NEEDED */
-
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  3
 /* YYLAST -- Last index in YYTABLE.  */
@@ -547,7 +531,7 @@ static const yytype_uint8 yyrline[] =
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE || 1
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
@@ -558,7 +542,7 @@ static const char *const yytname[] =
   "config", "group", "group_open", "group_close", "group_items", "assign",
   "$@1", "list", "list_open", "list_close", "list_items", "value",
   "literal", "separator", "path", "path_open", "path_close", "path_item",
-  "path_tag", YY_NULL
+  "path_tag", 0
 };
 #endif
 
@@ -590,8 +574,8 @@ static const yytype_uint8 yyr2[] =
        3,     1,     1
 };
 
-/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
-   Performed when YYTABLE doesn't specify something else to do.  Zero
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
 static const yytype_uint8 yydefact[] =
 {
@@ -630,7 +614,8 @@ static const yytype_int8 yypgoto[] =
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -3
 static const yytype_int8 yytable[] =
 {
@@ -640,12 +625,6 @@ static const yytype_int8 yytable[] =
       26,    42,     0,    37
 };
 
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-11)))
-
-#define yytable_value_is_error(Yytable_value) \
-  YYID (0)
-
 static const yytype_int8 yycheck[] =
 {
        6,     1,     0,     3,     4,     5,     6,     7,     8,     1,
@@ -677,50 +656,78 @@ static const yytype_uint8 yystos[] =
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  However,
-   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
-   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
-   discussed.  */
+   Once GCC version 2 has supplanted version 1, this can go.  */
 
 #define YYFAIL		goto yyerrlab
-#if defined YYFAIL
-  /* This is here to suppress warnings from the GCC cpp's
-     -Wunused-macros.  Normally we don't worry about that warning, but
-     some users do, and we want to make it easy for users to remove
-     YYFAIL uses, which will produce warnings from Bison 2.5.  */
-#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
-#define YYBACKUP(Token, Value)                                  \
-do                                                              \
-  if (yychar == YYEMPTY)                                        \
-    {                                                           \
-      yychar = (Token);                                         \
-      yylval = (Value);                                         \
-      YYPOPSTACK (yylen);                                       \
-      yystate = *yyssp;                                         \
-      goto yybackup;                                            \
-    }                                                           \
-  else                                                          \
-    {                                                           \
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
       yyerror (lexer, handlers, YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
 while (YYID (0))
 
-/* Error token number */
+
 #define YYTERROR	1
 #define YYERRCODE	256
 
 
-/* This macro is provided for backward compatibility. */
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
 #ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
 #endif
 
 
 /* YYLEX -- calling `yylex' with the right arguments.  */
+
 #ifdef YYLEX_PARAM
 # define YYLEX yylex (&yylval, YYLEX_PARAM)
 #else
@@ -772,8 +779,6 @@ yy_symbol_value_print (yyoutput, yytype, yyvaluep, lexer, handlers)
     struct TsConfigHandlers* handlers;
 #endif
 {
-  FILE *yyo = yyoutput;
-  YYUSE (yyo);
   if (!yyvaluep)
     return;
   YYUSE (lexer);
@@ -787,7 +792,7 @@ yy_symbol_value_print (yyoutput, yytype, yyvaluep, lexer, handlers)
   switch (yytype)
     {
       default:
-        break;
+	break;
     }
 }
 
@@ -917,6 +922,7 @@ int yydebug;
 # define YYMAXDEPTH 10000
 #endif
 
+
 
 #if YYERROR_VERBOSE
 
@@ -1019,145 +1025,115 @@ yytnamerr (char *yyres, const char *yystr)
 }
 # endif
 
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULL;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - Assume YYFAIL is not used.  It's too flawed to consider.  See
-       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
-       for details.  YYERROR is fine as it does not invoke this
-       function.
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);
-                  if (! (yysize <= yysize1
-                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                    return 2;
-                  yysize = yysize1;
-                }
-              }
-        }
-    }
+  int yyn = yypact[yystate];
 
-  switch (yycount)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
 
-  {
-    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
-    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-      return 2;
-    yysize = yysize1;
-  }
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
 
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
 
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
 }
 #endif /* YYERROR_VERBOSE */
+
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
@@ -1190,16 +1166,32 @@ yydestruct (yymsg, yytype, yyvaluep, lexer, handlers)
     {
 
       default:
-        break;
+	break;
     }
 }
 
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (yyscan_t lexer, struct TsConfigHandlers* handlers);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
 
 
 
-/*----------.
-| yyparse.  |
-`----------*/
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
 
 #ifdef YYPARSE_PARAM
 #if (defined __STDC__ || defined __C99__FUNC__ \
@@ -1227,31 +1219,8 @@ yyparse (lexer, handlers)
 /* The lookahead symbol.  */
 int yychar;
 
-
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
-/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
-    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
-    _Pragma ("GCC diagnostic pop")
-#else
-/* Default value used for initialization, for pacifying older GCCs
-   or non-GCC compilers.  */
-static YYSTYPE yyval_default;
-# define YY_INITIAL_VALUE(Value) = Value
-#endif
-#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END
-#endif
-#ifndef YY_INITIAL_VALUE
-# define YY_INITIAL_VALUE(Value) /* Nothing. */
-#endif
-
 /* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);
+YYSTYPE yylval;
 
     /* Number of syntax errors so far.  */
     int yynerrs;
@@ -1264,7 +1233,7 @@ YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);
        `yyss': related to states.
        `yyvs': related to semantic values.
 
-       Refer to the stacks through separate pointers, to allow yyoverflow
+       Refer to the stacks thru separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
 
     /* The state stack.  */
@@ -1282,7 +1251,7 @@ YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);
   int yyn;
   int yyresult;
   /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
+  int yytoken;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
@@ -1300,8 +1269,9 @@ YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
   yystacksize = YYINITDEPTH;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
@@ -1310,6 +1280,14 @@ YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);
   yyerrstatus = 0;
   yynerrs = 0;
   yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
   goto yysetstate;
 
 /*------------------------------------------------------------.
@@ -1401,7 +1379,7 @@ yybackup:
 
   /* First try to decide what to do without reference to lookahead token.  */
   yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
@@ -1432,8 +1410,8 @@ yybackup:
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
@@ -1450,9 +1428,7 @@ yybackup:
   yychar = YYEMPTY;
 
   yystate = yyn;
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
 
   goto yynewstate;
 
@@ -1489,81 +1465,81 @@ yyreduce:
   switch (yyn)
     {
         case 4:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 90 "TsConfigGrammar.y"
     { HANDLE_EVENT(GroupOpen, (yyvsp[(1) - (1)])); }
     break;
 
   case 5:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 92 "TsConfigGrammar.y"
     { HANDLE_EVENT(GroupClose, (yyvsp[(1) - (1)])); }
     break;
 
   case 9:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 96 "TsConfigGrammar.y"
     { HANDLE_EVENT(GroupName, (yyvsp[(1) - (2)])); }
     break;
 
   case 12:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 100 "TsConfigGrammar.y"
     { HANDLE_EVENT(ListOpen, (yyvsp[(1) - (1)])); }
     break;
 
   case 13:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 102 "TsConfigGrammar.y"
     { HANDLE_EVENT(ListClose, (yyvsp[(1) - (1)])); }
     break;
 
   case 17:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 106 "TsConfigGrammar.y"
     { HANDLE_EVENT(LiteralValue, (yyvsp[(1) - (1)])); }
     break;
 
   case 27:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 114 "TsConfigGrammar.y"
     { HANDLE_EVENT(PathOpen, (yyvsp[(1) - (1)])); }
     break;
 
   case 28:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 116 "TsConfigGrammar.y"
     { HANDLE_EVENT(PathClose, (yyvsp[(1) - (1)])); }
     break;
 
   case 31:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 120 "TsConfigGrammar.y"
     { HANDLE_EVENT(PathTag, (yyvsp[(1) - (1)])); }
     break;
 
   case 32:
-/* Line 1792 of yacc.c  */
+
+/* Line 1455 of yacc.c  */
 #line 120 "TsConfigGrammar.y"
     { HANDLE_EVENT(PathIndex, (yyvsp[(1) - (1)])); }
     break;
 
 
-/* Line 1792 of yacc.c  */
-#line 1554 "TsConfigGrammar.c"
+
+/* Line 1455 of yacc.c  */
+#line 1541 "TsConfigGrammar.c"
       default: break;
     }
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
@@ -1591,10 +1567,6 @@ yyreduce:
 | yyerrlab -- here on detecting error |
 `------------------------------------*/
 yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
@@ -1602,36 +1574,37 @@ yyerrlab:
 #if ! YYERROR_VERBOSE
       yyerror (lexer, handlers, YY_("syntax error"));
 #else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
       {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (lexer, handlers, yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (lexer, handlers, yymsg);
+	  }
+	else
+	  {
+	    yyerror (lexer, handlers, YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
       }
-# undef YYSYNTAX_ERROR
 #endif
     }
 
@@ -1690,7 +1663,7 @@ yyerrlab1:
   for (;;)
     {
       yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
+      if (yyn != YYPACT_NINF)
 	{
 	  yyn += YYTERROR;
 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
@@ -1713,9 +1686,7 @@ yyerrlab1:
       YY_STACK_PRINT (yyss, yyssp);
     }
 
-  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
-  YY_IGNORE_MAYBE_UNINITIALIZED_END
 
 
   /* Shift the error token.  */
@@ -1739,7 +1710,7 @@ yyabortlab:
   yyresult = 1;
   goto yyreturn;
 
-#if !defined yyoverflow || YYERROR_VERBOSE
+#if !defined(yyoverflow) || YYERROR_VERBOSE
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -1751,13 +1722,8 @@ yyexhaustedlab:
 
 yyreturn:
   if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval, lexer, handlers);
-    }
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval, lexer, handlers);
   /* Do not reclaim the symbols of the rule which action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
@@ -1781,8 +1747,10 @@ yyreturn:
 }
 
 
-/* Line 2055 of yacc.c  */
+
+/* Line 1675 of yacc.c  */
 #line 122 "TsConfigGrammar.y"
 
 
 # endif // __clang_analyzer__
+
diff --git a/lib/tsconfig/TsConfigGrammar.h b/lib/tsconfig/TsConfigGrammar.h
index 52f083b..d3581d9 100644
--- a/lib/tsconfig/TsConfigGrammar.h
+++ b/lib/tsconfig/TsConfigGrammar.h
@@ -1,19 +1,21 @@
-/* A Bison parser, made by GNU Bison 2.7.  */
 
-/* Bison interface for Yacc-like parsers in C
-
-      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
+/* A Bison parser, made by GNU Bison 2.4.1.  */
 
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
-
+   
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-
+   
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
@@ -26,21 +28,13 @@
    special exception, which will cause the skeleton and the resulting
    Bison output files to be licensed under the GNU General Public
    License without this special exception.
-
+   
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-#ifndef YY_TSCONFIG_TSCONFIGGRAMMAR_H_INCLUDED
-# define YY_TSCONFIG_TSCONFIGGRAMMAR_H_INCLUDED
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int tsconfigdebug;
-#endif
 /* "%code requires" blocks.  */
-/* Line 2058 of yacc.c  */
+
+/* Line 1676 of yacc.c  */
 #line 1 "TsConfigGrammar.y"
 
 /** @file
@@ -67,8 +61,9 @@ extern int tsconfigdebug;
  */
 
 
-/* Line 2058 of yacc.c  */
-#line 72 "TsConfigGrammar.h"
+
+/* Line 1676 of yacc.c  */
+#line 67 "TsConfigGrammar.h"
 
 /* Tokens.  */
 #ifndef YYTOKENTYPE
@@ -106,6 +101,7 @@ extern int tsconfigdebug;
 
 
 
+
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef int YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
@@ -114,18 +110,5 @@ typedef int YYSTYPE;
 #endif
 
 
-#ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
-int tsconfigparse (void *YYPARSE_PARAM);
-#else
-int tsconfigparse ();
-#endif
-#else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
-int tsconfigparse (yyscan_t lexer, struct TsConfigHandlers* handlers);
-#else
-int tsconfigparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
 
-#endif /* !YY_TSCONFIG_TSCONFIGGRAMMAR_H_INCLUDED  */
+
diff --git a/plugins/cacheurl/cacheurl.cc b/plugins/cacheurl/cacheurl.cc
index 52565fc..d17c732 100644
--- a/plugins/cacheurl/cacheurl.cc
+++ b/plugins/cacheurl/cacheurl.cc
@@ -28,8 +28,8 @@
 #include "ts/ts.h"
 #include "ts/remap.h"
 #include "ink_defs.h"
+#include "ink_memory.h"
 
-#include <memory>
 #include <string>
 #include <vector>
 
@@ -205,7 +205,7 @@ load_config_file(const char *config_file)
   char buffer[1024];
   std::string path;
   TSFile fh;
-  std::auto_ptr<pr_list> prl(new pr_list());
+  ats_scoped_obj<pr_list> prl(new pr_list());
 
   /* locations in a config file line, end of line, split start, split end */
   char *eol, *spstart, *spend;
diff --git a/plugins/experimental/Makefile.am b/plugins/experimental/Makefile.am
index 52fef44..adb6da8 100644
--- a/plugins/experimental/Makefile.am
+++ b/plugins/experimental/Makefile.am
@@ -19,6 +19,7 @@ SUBDIRS = \
  background_fetch \
  balancer \
  buffer_upload \
+ cache_promote \
  cache_range_requests \
  channel_stats \
  collapsed_connection \
@@ -38,6 +39,7 @@ SUBDIRS = \
  ssl_cert_loader \
  sslheaders \
  stale_while_revalidate \
+ stream_editor \
  url_sig \
  xdebug
 
diff --git a/plugins/experimental/cache_promote/Makefile.am b/plugins/experimental/cache_promote/Makefile.am
new file mode 100644
index 0000000..8170aed
--- /dev/null
+++ b/plugins/experimental/cache_promote/Makefile.am
@@ -0,0 +1,21 @@
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  "License"); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+include $(top_srcdir)/build/plugins.mk
+
+pkglib_LTLIBRARIES = cache_promote.la
+cache_promote_la_SOURCES = cache_promote.cc
+cache_promote_la_LDFLAGS = $(TS_PLUGIN_LDFLAGS)
diff --git a/plugins/experimental/cache_promote/README b/plugins/experimental/cache_promote/README
new file mode 100644
index 0000000..26d4500
--- /dev/null
+++ b/plugins/experimental/cache_promote/README
@@ -0,0 +1,30 @@
+LRU Design
+==========
+
+This got slightly complex, because I tried to be clever. But the concept is easy, a
+list and an unordered map keeps the LRU state.
+
+
+                                                    +-----------------------+    +----------------------------------+
+                                                    |        LRUList        |    |              LRUMap              |
+                                                    |        -------        |    |              ------              |
+                                                    |+---------------------+|    |+--------------------------------+|
++---------------------+   +---------------------+   ||      LRUEntry       <+----+| {LRUHash *, LRUList::iterator} ||
+|       LRUHash       |   |      LRUEntry       |   |+---------------------+|    |+--------------------------------+|
+|      --------       |<--+      --------       |<--+|      LRUEntry       <+----+| {LRUHash *, LRUList::iterator} ||
+|  u_char _hash[20]   |   | <LRUHash, unsigned> |   |+---------------------+|    |+--------------------------------+|
++---------------------+   +---------------------+   ||      LRUEntry       <+----+| {LRUHash *, LRUList::iterator} ||
+                            +-----------------+     |+---------------------+|    |+--------------------------------+|
+                            | first = LRUHash |     |                       |    |                                  |
+                            |second = unsigned|     |           *           |    |                *                 |
+                            +-----------------+     |           *           |    |                *                 |
+                                                    |           *           |    |                *                 |
+                                                    |                       |    |                                  |
+                                                    |+---------------------+|    |+--------------------------------+|
+                                                    ||      LRUEntry       ||    || {LRUHash *, LRUList::iterator} ||
+                                                    |+---------------------+|    |+--------------------------------+|
+                                                    +-----------------------+    +----------------------------------+
+                                                                                     +--------------------------+
+                                                                                     |    first  = LRUHash*     |
+                                                                                     |second = LRUList::iterator|
+                                                                                     +--------------------------+
diff --git a/plugins/experimental/cache_promote/cache_promote.cc b/plugins/experimental/cache_promote/cache_promote.cc
new file mode 100644
index 0000000..c601927
--- /dev/null
+++ b/plugins/experimental/cache_promote/cache_promote.cc
@@ -0,0 +1,515 @@
+/*
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+  http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <time.h>
+#include <openssl/sha.h>
+
+#include <string>
+#include <unordered_map>
+#include <list>
+
+#include "ts/ts.h"
+#include "ts/remap.h"
+#include "ts/ink_config.h"
+
+
+static const char *PLUGIN_NAME = "cache_promote";
+TSCont gNocacheCont;
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// Note that all options for all policies has to go here. Not particularly pretty...
+//
+static const struct option longopt[] = {{const_cast<char *>("policy"), required_argument, NULL, 'p'},
+                                        // This is for both Chance and LRU (optional) policy
+                                        {const_cast<char *>("sample"), required_argument, NULL, 's'},
+                                        // For the LRU policy
+                                        {const_cast<char *>("buckets"), required_argument, NULL, 'b'},
+                                        {const_cast<char *>("hits"), required_argument, NULL, 'h'},
+                                        // EOF
+                                        {NULL, no_argument, NULL, '\0'}};
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// Abstract base class for all policies.
+//
+class PromotionPolicy
+{
+public:
+  PromotionPolicy() : _sample(0.0)
+  {
+    // This doesn't have to be perfect, since this is just chance sampling.
+    // coverity[dont_call]
+    srand48((long)time(NULL));
+  }
+
+  void
+  setSample(char *s)
+  {
+    _sample = strtof(s, NULL) / 100.0;
+  }
+
+  float
+  getSample() const
+  {
+    return _sample;
+  }
+
+  bool
+  doSample() const
+  {
+    if (_sample > 0) {
+      // coverity[dont_call]
+      double r = drand48();
+
+      if (_sample > r) {
+        TSDebug(PLUGIN_NAME, "checking sampling, is %f > %f? Yes!", _sample, r);
+      } else {
+        TSDebug(PLUGIN_NAME, "checking sampling, is %f > %f? No!", _sample, r);
+        return false;
+      }
+    }
+    return true;
+  }
+
+  virtual ~PromotionPolicy(){};
+
+  virtual bool
+  parseOption(int opt, char *optarg)
+  {
+    return false;
+  }
+
+  // These are pure virtual
+  virtual bool doPromote(TSHttpTxn txnp) = 0;
+  virtual const char *policyName() const = 0;
+  virtual void usage() const = 0;
+
+private:
+  float _sample;
+};
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// This is the simplest of all policies, just give each request a (small)
+// percentage chance to be promoted to cache.
+//
+class ChancePolicy : public PromotionPolicy
+{
+public:
+  bool doPromote(TSHttpTxn /* txnp ATS_UNUSED */)
+  {
+    TSDebug(PLUGIN_NAME, "ChancePolicy::doPromote(%f)", getSample());
+    return true;
+  }
+
+  void
+  usage() const
+  {
+    TSError("[%s] Usage: @plugin=%s.so @pparam=--policy=chance @pparam=--sample=<x>%%", PLUGIN_NAME, PLUGIN_NAME);
+  }
+
+  const char *
+  policyName() const
+  {
+    return "chance";
+  }
+};
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// The LRU based policy keeps track of <bucket> number of URLs, with a counter for each slot.
+// Objects are not promoted unless the counter reaches <hits> before it gets evicted. An
+// optional <chance> parameter can be used to sample hits, this can reduce contention and
+// churning in the LRU as well.
+//
+class LRUHash
+{
+  friend struct LRUHashHasher;
+
+public:
+  LRUHash() { TSDebug(PLUGIN_NAME, "In LRUHash()"); }
+
+  ~LRUHash() { TSDebug(PLUGIN_NAME, "In ~LRUHash()"); }
+
+  LRUHash &operator=(const LRUHash &h)
+  {
+    TSDebug(PLUGIN_NAME, "copying an LRUHash object");
+    memcpy(_hash, h._hash, sizeof(_hash));
+    return *this;
+  }
+
+  void
+  init(char *data, int len)
+  {
+    SHA_CTX sha;
+
+    SHA1_Init(&sha);
+    SHA1_Update(&sha, data, len);
+    SHA1_Final(_hash, &sha);
+  }
+
+private:
+  u_char _hash[SHA_DIGEST_LENGTH];
+};
+
+struct LRUHashHasher {
+  bool operator()(const LRUHash *s1, const LRUHash *s2) const { return 0 == memcmp(s1->_hash, s2->_hash, sizeof(s2->_hash)); }
+
+  size_t operator()(const LRUHash *s) const { return *((size_t *)s->_hash) ^ *((size_t *)(s->_hash + 9)); }
+};
+
+typedef std::pair<LRUHash, unsigned> LRUEntry;
+typedef std::list<LRUEntry> LRUList;
+typedef std::unordered_map<const LRUHash *, LRUList::iterator, LRUHashHasher, LRUHashHasher> LRUMap;
+
+static LRUEntry NULL_LRU_ENTRY; // Used to create an "empty" new LRUEntry
+
+class LRUPolicy : public PromotionPolicy
+{
+public:
+  LRUPolicy() : PromotionPolicy(), _buckets(1000), _hits(10), _lock(TSMutexCreate()) {}
+
+  ~LRUPolicy()
+  {
+    TSDebug(PLUGIN_NAME, "deleting LRUPolicy object");
+    TSMutexLock(_lock);
+
+    _map.clear();
+    _list.clear();
+    _freelist.clear();
+
+    TSMutexUnlock(_lock);
+    TSMutexDestroy(_lock);
+  }
+
+  bool
+  parseOption(int opt, char *optarg)
+  {
+    switch (opt) {
+    case 'b':
+      _buckets = static_cast<unsigned>(strtol(optarg, NULL, 10));
+      break;
+    case 'h':
+      _hits = static_cast<unsigned>(strtol(optarg, NULL, 10));
+      break;
+    default:
+      // All other options are unsupported for this policy
+      return false;
+    }
+
+    // This doesn't have to be perfect, since this is just chance sampling.
+    // coverity[dont_call]
+    srand48((long)time(NULL) ^ (long)getpid() ^ (long)getppid());
+
+    return true;
+  }
+
+  bool
+  doPromote(TSHttpTxn txnp)
+  {
+    LRUHash hash;
+    LRUMap::iterator map_it;
+    int url_len = 0;
+    char *url = TSHttpTxnEffectiveUrlStringGet(txnp, &url_len);
+    bool ret = false;
+
+    // Generally shouldn't happen ...
+    if (!url) {
+      return false;
+    }
+
+    TSDebug(PLUGIN_NAME, "LRUPolicy::doPromote(%.*s ...)", url_len > 30 ? 30 : url_len, url);
+    hash.init(url, url_len);
+    TSfree(url);
+
+    // We have to hold the lock across all list and hash access / updates
+    TSMutexLock(_lock);
+
+    map_it = _map.find(&hash);
+    if (_map.end() != map_it) {
+      // We have an entry in the LRU
+      if (++(map_it->second->second) >= _hits) {
+        // Promoted! Cleanup the LRU, and signal success. Save the promoted entry on the freelist.
+        TSDebug(PLUGIN_NAME, "saving the LRUEntry to the freelist");
+        _freelist.splice(_freelist.begin(), _list, map_it->second);
+        _map.erase(map_it->first);
+        ret = true;
+      } else {
+        // It's still not promoted, make sure it's moved to the front of the list
+        TSDebug(PLUGIN_NAME, "still not promoted, got %d hits so far", map_it->second->second);
+        _list.splice(_list.begin(), _list, map_it->second);
+      }
+    } else {
+      // New LRU entry for the URL, try to repurpose the list entry as much as possible
+      if (_list.size() >= _buckets) {
+        TSDebug(PLUGIN_NAME, "repurposing last LRUHash entry");
+        _list.splice(_list.begin(), _list, --_list.end());
+        _map.erase(&(_list.begin()->first));
+      } else if (_freelist.size() > 0) {
+        TSDebug(PLUGIN_NAME, "reusing LRUEntry from freelist");
+        _list.splice(_list.begin(), _freelist, _freelist.begin());
+      } else {
+        TSDebug(PLUGIN_NAME, "creating new LRUEntry");
+        _list.push_front(NULL_LRU_ENTRY);
+      }
+      // Update the "new" LRUEntry and add it to the hash
+      _list.begin()->first = hash;
+      _list.begin()->second = 1;
+      _map[&(_list.begin()->first)] = _list.begin();
+    }
+
+    TSMutexUnlock(_lock);
+
+    return ret;
+  }
+
+  void
+  usage() const
+  {
+    TSError("[%s] Usage: @plugin=%s.so @pparam=--policy=lru @pparam=--buckets=<n> --hits=<m> --sample=<x>", PLUGIN_NAME,
+            PLUGIN_NAME);
+  }
+
+  const char *
+  policyName() const
+  {
+    return "LRU";
+  }
+
+private:
+  unsigned _buckets;
+  unsigned _hits;
+  // For the LRU
+  TSMutex _lock;
+  LRUMap _map;
+  LRUList _list, _freelist;
+};
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// This holds the configuration for a remap rule, as well as parses the configurations.
+//
+class PromotionConfig
+{
+public:
+  PromotionConfig() : _policy(NULL) {}
+
+  ~PromotionConfig() { delete _policy; }
+
+  PromotionPolicy *
+  getPolicy() const
+  {
+    return _policy;
+  }
+
+  // Parse the command line arguments to the plugin, and instantiate the appropriate policy
+  bool
+  factory(int argc, char *argv[])
+  {
+    optind = 0;
+    while (true) {
+      int opt = getopt_long(argc, (char *const *)argv, "psbh", longopt, NULL);
+
+      if (opt == -1) {
+        break;
+      } else if (opt == 'p') {
+        if (0 == strncasecmp(optarg, "chance", 6)) {
+          _policy = new ChancePolicy();
+        } else if (0 == strncasecmp(optarg, "lru", 3)) {
+          _policy = new LRUPolicy();
+        } else {
+          TSError("[%s] Unknown policy --policy=%s", PLUGIN_NAME, optarg);
+          return false;
+        }
+        if (_policy) {
+          TSDebug(PLUGIN_NAME, "created remap with cache promotion policy = %s", _policy->policyName());
+        }
+      } else {
+        if (_policy) {
+          // The --sample (-s) option is allowed for all configs, but only after --policy is specified.
+          if (opt == 's') {
+            _policy->setSample(optarg);
+          } else {
+            if (!_policy->parseOption(opt, optarg)) {
+              TSError("[%s] The specified policy (%s) does not support the -%c option", PLUGIN_NAME, _policy->policyName(), opt);
+              delete _policy;
+              _policy = NULL;
+              return false;
+            }
+          }
+        } else {
+          TSError("[%s] The --policy=<n> parameter must come first on the remap configuration", PLUGIN_NAME);
+          return false;
+        }
+      }
+    }
+
+    return true;
+  }
+
+private:
+  PromotionPolicy *_policy;
+};
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// Little helper continuation, to turn off writing to the cache. ToDo: when we have proper
+// APIs to make requests / responses, we can remove this completely.
+static int
+cont_nocache_response(TSCont contp, TSEvent event, void *edata)
+{
+  TSHttpTxn txnp = static_cast<TSHttpTxn>(edata);
+
+  TSHttpTxnServerRespNoStoreSet(txnp, 1);
+  // Reenable and continue with the state machine.
+  TSHttpTxnReenable(txnp, TS_EVENT_HTTP_CONTINUE);
+  return 0;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// Main "plugin", a TXN hook in the TS_HTTP_READ_CACHE_HDR_HOOK. Unless the policy allows
+// caching, we will turn off the cache from here on for the TXN.
+//
+// NOTE: This is not optimal, the goal was to handle this before we lock the URL in the
+// cache. However, that does not work. Hence, for now, we also schedule the continuation
+// for READ_RESPONSE_HDR such that we can turn off  the actual cache write.
+//
+static int
+cont_handle_policy(TSCont contp, TSEvent event, void *edata)
+{
+  TSHttpTxn txnp = static_cast<TSHttpTxn>(edata);
+  PromotionConfig *config = static_cast<PromotionConfig *>(TSContDataGet(contp));
+
+  switch (event) {
+  // Main HOOK
+  case TS_EVENT_HTTP_CACHE_LOOKUP_COMPLETE:
+    if (TS_SUCCESS != TSHttpIsInternalRequest(txnp)) {
+      int obj_status;
+
+      if (TS_ERROR != TSHttpTxnCacheLookupStatusGet(txnp, &obj_status)) {
+        switch (obj_status) {
+        case TS_CACHE_LOOKUP_MISS:
+        case TS_CACHE_LOOKUP_SKIPPED:
+          if (config->getPolicy()->doSample() && config->getPolicy()->doPromote(txnp)) {
+            TSDebug(PLUGIN_NAME, "cache-status is %d, and leaving cache on (promoted)", obj_status);
+          } else {
+            TSDebug(PLUGIN_NAME, "cache-status is %d, and turning off the cache (not promoted)", obj_status);
+            TSHttpTxnHookAdd(txnp, TS_HTTP_READ_RESPONSE_HDR_HOOK, gNocacheCont);
+          }
+          break;
+        default:
+          // Do nothing, just let it handle the lookup.
+          TSDebug(PLUGIN_NAME, "cache-status is %d (hit), nothing to do", obj_status);
+          break;
+        }
+      }
+    } else {
+      TSDebug(PLUGIN_NAME, "Request is an internal (plugin) request, implicitly promoted");
+    }
+    break;
+
+  // Should not happen
+  default:
+    TSDebug(PLUGIN_NAME, "Unhandled event %d", (int)event);
+    break;
+  }
+
+  // Reenable and continue with the state machine.
+  TSHttpTxnReenable(txnp, TS_EVENT_HTTP_CONTINUE);
+  return 0;
+}
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// Initialize the plugin as a remap plugin.
+//
+TSReturnCode
+TSRemapInit(TSRemapInterface *api_info, char *errbuf, int errbuf_size)
+{
+  if (api_info->size < sizeof(TSRemapInterface)) {
+    strncpy(errbuf, "[tsremap_init] - Incorrect size of TSRemapInterface structure", errbuf_size - 1);
+    return TS_ERROR;
+  }
+
+  if (api_info->tsremap_version < TSREMAP_VERSION) {
+    snprintf(errbuf, errbuf_size - 1, "[tsremap_init] - Incorrect API version %ld.%ld", api_info->tsremap_version >> 16,
+             (api_info->tsremap_version & 0xffff));
+    return TS_ERROR;
+  }
+
+  gNocacheCont = TSContCreate(cont_nocache_response, NULL);
+
+  TSDebug(PLUGIN_NAME, "remap plugin is successfully initialized");
+  return TS_SUCCESS; /* success */
+}
+
+
+TSReturnCode
+TSRemapNewInstance(int argc, char *argv[], void **ih, char * /* errbuf */, int /* errbuf_size */)
+{
+  PromotionConfig *config = new PromotionConfig;
+
+  --argc;
+  ++argv;
+  if (config->factory(argc, argv)) {
+    TSCont contp = TSContCreate(cont_handle_policy, NULL);
+
+    TSContDataSet(contp, static_cast<void *>(config));
+    *ih = static_cast<void *>(contp);
+
+    return TS_SUCCESS;
+  } else {
+    delete config;
+    return TS_ERROR;
+  }
+}
+
+void
+TSRemapDeleteInstance(void *ih)
+{
+  TSCont contp = static_cast<TSCont>(ih);
+  PromotionConfig *config = static_cast<PromotionConfig *>(TSContDataGet(contp));
+
+  delete config;
+  TSContDestroy(contp);
+}
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+// Schedule the cache-read continuation for this remap rule.
+//
+TSRemapStatus
+TSRemapDoRemap(void *ih, TSHttpTxn rh, TSRemapRequestInfo * /* ATS_UNUSED rri */)
+{
+  if (NULL == ih) {
+    TSDebug(PLUGIN_NAME, "No promotion rules configured, this is probably a plugin bug");
+  } else {
+    TSCont contp = static_cast<TSCont>(ih);
+
+    TSDebug(PLUGIN_NAME, "scheduling a TS_HTTP_CACHE_LOOKUP_COMPLETE_HOOK hook");
+    TSHttpTxnHookAdd(rh, TS_HTTP_CACHE_LOOKUP_COMPLETE_HOOK, contp);
+  }
+
+  return TSREMAP_NO_REMAP;
+}
diff --git a/plugins/experimental/money_trace/Makefile.am b/plugins/experimental/money_trace/Makefile.am
new file mode 100644
index 0000000..d63485f
--- /dev/null
+++ b/plugins/experimental/money_trace/Makefile.am
@@ -0,0 +1,22 @@
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  "License"); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+include $(top_srcdir)/build/plugins.mk
+
+pkglib_LTLIBRARIES = money_trace.la
+money_trace_la_SOURCES = money_trace.cc 
+money_trace_la_LDFLAGS = $(TS_PLUGIN_LDFLAGS)
+
diff --git a/plugins/experimental/money_trace/README b/plugins/experimental/money_trace/README
new file mode 100644
index 0000000..a495897
--- /dev/null
+++ b/plugins/experimental/money_trace/README
@@ -0,0 +1,8 @@
+
+Author: John J. Rushford, John_Rushford@cable.comcast.com
+
+Money trace plugin 
+  This is a remap plugin used to add and update a "X-MoneyTrace" used to trace and monitor http transactions in support system logs.
+
+See the documentation on this header at https://github.com/Comcast/money/wiki.
+
diff --git a/plugins/experimental/money_trace/money_trace.cc b/plugins/experimental/money_trace/money_trace.cc
new file mode 100644
index 0000000..adb8980
--- /dev/null
+++ b/plugins/experimental/money_trace/money_trace.cc
@@ -0,0 +1,365 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * This plugin looks for range requests and then creates a new
+ * cache key url so that each individual range requests is written
+ * to the cache as a individual object so that subsequent range
+ * requests are read accross different disk drives reducing I/O
+ * wait and load averages when there are large numbers of range
+ * requests.
+ */
+
+#include <iostream>
+#include <sstream>
+#include <stdio.h>
+#include <string.h>
+#include "ts/ts.h"
+#include "ts/remap.h"
+
+#include "money_trace.h"
+
+/**
+ * Allocate transaction data structure.
+ */
+static struct txndata *
+allocTransactionData()
+{
+  LOG_DEBUG("allocating transaction state data.");
+  struct txndata *txn_data = (struct txndata *)TSmalloc(sizeof(struct txndata));
+  txn_data->client_request_mt_header = NULL;
+  txn_data->new_span_mt_header = NULL;
+  return txn_data;
+}
+
+/**
+ * free any previously allocated transaction data.
+ */
+static void
+freeTransactionData(struct txndata *txn_data)
+{
+  LOG_DEBUG("de-allocating transaction state data.");
+  if (txn_data->client_request_mt_header != NULL) {
+    LOG_DEBUG("freeing txn_data->client_request_mt_header");
+    TSfree(txn_data->client_request_mt_header);
+  }
+  if (txn_data->new_span_mt_header != NULL) {
+    LOG_DEBUG("freeing txn_data->new_span_mt_header.");
+    TSfree(txn_data->new_span_mt_header);
+  }
+  if (txn_data != NULL) {
+    LOG_DEBUG("freeing txn_data.");
+    TSfree(txn_data);
+  }
+}
+
+/**
+ * The TS_EVENT_HTTP_CACHE_LOOKUP_COMPLETE event callback.
+ * 
+ * If there is a cache hit only schedule a TS_HTTP_SEND_RESPONSE_HDR_HOOK
+ * continuation to send back the money trace header in the response to the
+ * client.
+ *
+ * If there is a cache miss, a new money trace header is created and a
+ * TS_HTTP_SEND_REQUES_HDR_HOOK continuation is scheduled to add the
+ * new money trace header to the parent request.
+ */ 
+static void
+mt_cache_lookup_check(TSCont contp, TSHttpTxn txnp, struct txndata *txn_data)
+{
+  MT generator;
+  int cache_result = 0;
+  char *new_mt_header;
+
+  if (TS_SUCCESS != TSHttpTxnCacheLookupStatusGet(txnp, &cache_result)) {
+    LOG_ERROR("Unable to get cache status.");
+  } else {
+    switch (cache_result) {
+    case TS_CACHE_LOOKUP_MISS:
+    case TS_CACHE_LOOKUP_SKIPPED:
+      new_mt_header = (char *)generator.moneyTraceHdr(txn_data->client_request_mt_header);
+      if (new_mt_header != NULL) {
+        LOG_DEBUG("cache miss, built a new money trace header: %s.", new_mt_header);
+        txn_data->new_span_mt_header = new_mt_header;
+      } else {
+        LOG_DEBUG("failed to build a new money trace header.");
+      }
+      TSHttpTxnHookAdd(txnp, TS_HTTP_SEND_REQUEST_HDR_HOOK, contp);
+
+    // fall through to the default as we always need to send the original
+    // money trace header received from the client back to the client in the
+    // response
+    default:
+      TSHttpTxnHookAdd(txnp, TS_HTTP_SEND_RESPONSE_HDR_HOOK, contp);
+      break;
+    }
+  }
+}
+
+/**
+ * remap entry point, called to check for the existence of a money trace
+ * header.  If there is one, schedule the continuation to call back and
+ * process on TS_HTTP_CACHE_LOOKUP_COMPLETE_HOOK and TS_HTTP_TXN_CLOSE_HOOK.
+ */
+static void
+mt_check_request_header(TSHttpTxn txnp)
+{
+  int length = 0;
+  struct txndata *txn_data = NULL;
+  TSMBuffer bufp;
+  TSMLoc hdr_loc = NULL, field_loc = NULL;
+  TSCont contp;
+
+  // check for a money trace header.  If there is one, schedule appropriate continuations.
+  if (TS_SUCCESS == TSHttpTxnClientReqGet(txnp, &bufp, &hdr_loc)) {
+    field_loc = TSMimeHdrFieldFind(bufp, hdr_loc, MIME_FIELD_MONEY_TRACE, MIME_LEN_MONEY_TRACE);
+    if (TS_NULL_MLOC != field_loc) {
+      const char *hdr_value = TSMimeHdrFieldValueStringGet(bufp, hdr_loc, field_loc, 0, &length);
+      if (!hdr_value || length <= 0) {
+        LOG_DEBUG("ignoring, corrupt money trace header.");
+      } else {
+        txn_data = allocTransactionData();
+        txn_data->client_request_mt_header = TSstrndup(hdr_value, length);
+        txn_data->client_request_mt_header[length] = '\0'; // workaround for bug in core.
+        LOG_DEBUG("found money trace header: %s, length: %d", txn_data->client_request_mt_header, length);
+        if (NULL == (contp = TSContCreate(transaction_handler, NULL))) {
+          LOG_ERROR("failed to create the transaction handler continuation");
+        } else {
+          TSContDataSet(contp, txn_data);
+          TSHttpTxnHookAdd(txnp, TS_HTTP_CACHE_LOOKUP_COMPLETE_HOOK, contp);
+          TSHttpTxnHookAdd(txnp, TS_HTTP_TXN_CLOSE_HOOK, contp);
+        }
+      }
+    } else {
+      LOG_DEBUG("no money trace header was found in the request.");
+    }
+  } else {
+    LOG_DEBUG("failed to retrieve the client request.");
+  }
+  TSHandleMLocRelease(bufp, hdr_loc, field_loc);
+}
+
+/**
+ * The TS_EVENT_HTTP_SEND_RESPONSE_HDR callback.
+ * 
+ * Adds the money trace header received in the client request to the
+ * client response headers.
+ */ 
+static void
+mt_send_client_response(TSHttpTxn txnp, struct txndata *txn_data)
+{
+  TSMBuffer bufp;
+  TSMLoc hdr_loc, field_loc;
+
+  if (txn_data->client_request_mt_header == NULL) {
+    LOG_DEBUG("no client request header to return.");
+    return;
+  }
+
+  // send back the money trace header received in the request
+  // back in the response to the client.
+  if (TS_SUCCESS != TSHttpTxnClientRespGet(txnp, &bufp, &hdr_loc)) {
+    LOG_DEBUG("could not get the server response headers.");
+    return;
+  } else {
+    if (TS_SUCCESS ==
+        TSMimeHdrFieldCreateNamed(bufp, hdr_loc, MIME_FIELD_MONEY_TRACE, strlen(MIME_FIELD_MONEY_TRACE), &field_loc)) {
+      if (TS_SUCCESS == TSMimeHdrFieldValueStringSet(bufp, hdr_loc, field_loc, -1, txn_data->client_request_mt_header,
+                                                     strlen(txn_data->client_request_mt_header))) {
+        LOG_DEBUG("response header added: %s: %s", MIME_FIELD_MONEY_TRACE, txn_data->client_request_mt_header);
+        TSMimeHdrFieldAppend(bufp, hdr_loc, field_loc);
+      }
+    } else {
+      LOG_DEBUG("failed to create money trace response header.");
+    }
+  }
+  TSHandleMLocRelease(bufp, hdr_loc, field_loc);
+
+  return;
+}
+
+/**
+ * The TS_EVENT_HTTP_SEND_REQUEST_HDR callback.
+ *
+ * When a parent request is made, this function adds the new
+ * money trace header to the parent request headers.
+ */
+static void
+mt_send_server_request(TSHttpTxn txnp, struct txndata *txn_data)
+{
+  TSMBuffer bufp;
+  TSMLoc hdr_loc, field_loc;
+
+  if (txn_data->new_span_mt_header == NULL) {
+    LOG_DEBUG("there is no new mt request header to send.");
+    return;
+  }
+
+  if (TS_SUCCESS == TSHttpTxnServerReqGet(txnp, &bufp, &hdr_loc)) {
+    field_loc = TSMimeHdrFieldFind(bufp, hdr_loc, MIME_FIELD_MONEY_TRACE, MIME_LEN_MONEY_TRACE);
+    if (TS_NULL_MLOC != field_loc) {
+      if (TS_SUCCESS == TSMimeHdrFieldValueStringSet(bufp, hdr_loc, field_loc, -1, txn_data->new_span_mt_header,
+                                                     strlen(txn_data->new_span_mt_header))) {
+        LOG_DEBUG("server request header updated: %s: %s", MIME_FIELD_MONEY_TRACE, txn_data->new_span_mt_header);
+      }
+    } else {
+      LOG_DEBUG("unable to retrieve the money trace header location from the server request headers.");
+      return;
+    }
+  }
+  TSHandleMLocRelease(bufp, hdr_loc, field_loc);
+
+  return;
+}
+
+/**
+ * Remap initialization.
+ */
+TSReturnCode
+TSRemapInit(TSRemapInterface *api_info, char *errbuf, int errbuf_size)
+{
+  if (!api_info) {
+    strncpy(errbuf, "[tsremap_init] - Invalid TSRemapInterface argument", errbuf_size - 1);
+    return TS_ERROR;
+  }
+
+  if (api_info->tsremap_version < TSREMAP_VERSION) {
+    snprintf(errbuf, errbuf_size - 1, "[TSRemapInit] - Incorrect API version %ld.%ld", api_info->tsremap_version >> 16,
+             (api_info->tsremap_version & 0xffff));
+    return TS_ERROR;
+  }
+
+  LOG_DEBUG("cache_range_requests remap is successfully initialized.");
+
+  return TS_SUCCESS;
+}
+
+/**
+ * not used, one instance per remap and no parameters are used.
+ */
+TSReturnCode
+TSRemapNewInstance(int argc, char *argv[], void **ih, char * /*errbuf */, int /* errbuf_size */)
+{
+  return TS_SUCCESS;
+}
+
+/**
+ * not used, one instance per remap
+ */
+void
+TSRemapDeleteInstance(void *ih)
+{
+  LOG_DEBUG("no op");
+}
+
+/**
+ * Remap entry point.
+ */
+TSRemapStatus
+TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo * /* rri */)
+{
+  mt_check_request_header(txnp);
+  return TSREMAP_NO_REMAP;
+}
+
+/**
+ * Transaction event handler.
+ */
+static int
+transaction_handler(TSCont contp, TSEvent event, void *edata)
+{
+  TSHttpTxn txnp = static_cast<TSHttpTxn>(edata);
+  struct txndata *txn_data = (struct txndata *)TSContDataGet(contp);
+
+  switch (event) {
+  case TS_EVENT_HTTP_CACHE_LOOKUP_COMPLETE:
+    LOG_DEBUG("transaction cache lookup complete.");
+    mt_cache_lookup_check(contp, txnp, txn_data);
+    break;
+  case TS_EVENT_HTTP_SEND_REQUEST_HDR:
+    LOG_DEBUG("updating send request headers.");
+    mt_send_server_request(txnp, txn_data);
+    break;
+  case TS_EVENT_HTTP_SEND_RESPONSE_HDR:
+    LOG_DEBUG("updating send response headers.");
+    mt_send_client_response(txnp, txn_data);
+    break;
+  case TS_EVENT_HTTP_TXN_CLOSE:
+    LOG_DEBUG("handling transacation close.");
+    freeTransactionData(txn_data);
+    TSContDestroy(contp);
+    break;
+  default:
+    TSAssert(!"Unexpected event");
+    break;
+  }
+  TSHttpTxnReenable(txnp, TS_EVENT_HTTP_CONTINUE);
+
+  return TS_SUCCESS;
+}
+
+const char *
+MT::moneyTraceHdr(const char *mt_request_hdr)
+{
+  char copy[8192] = {'\0'};
+  char *toks[3], *p = NULL, *saveptr = NULL;
+  std::ostringstream temp_str;
+  std::string mt_header_str;
+  int numtoks = 0;
+
+  if (mt_request_hdr == NULL) {
+    LOG_DEBUG("an empty header was passed in.");
+    return NULL;
+  } else {
+    strncpy(copy, mt_request_hdr, 8191);
+  }
+
+  // parse the money header.
+  p = strtok_r(copy, ";", &saveptr);
+  if (p != NULL) {
+    toks[numtoks++] = p;
+    // copy the traceid
+  } else {
+    LOG_DEBUG("failed to parse the money_trace_header: %s", mt_request_hdr);
+    return NULL;
+  }
+  do {
+    p = strtok_r(NULL, ";", &saveptr);
+    if (p != NULL) {
+      toks[numtoks++] = p;
+    }
+  } while (p != NULL && numtoks < 3);
+
+  if (numtoks != 3 || toks[0] == NULL || toks[1] == NULL || toks[2] == NULL) {
+    LOG_DEBUG("failed to parse the money_trace_header: %s", mt_request_hdr);
+    return NULL;
+  }
+
+  if (strncmp(toks[0], "trace-id", strlen("trace-id")) == 0 && strncmp(toks[2], "span-id", strlen("span-id")) == 0 &&
+      (p = strchr(toks[2], '=')) != NULL) {
+    temp_str << toks[0] << ";parent-id=" << p << ";span-id=0x" << std::hex << spanId() << std::ends;
+  } else {
+    LOG_DEBUG("invalid money_trace_header: %s", mt_request_hdr);
+    return NULL;
+  }
+
+  mt_header_str = temp_str.str();
+
+  return TSstrndup(mt_header_str.c_str(), mt_header_str.length());
+}
diff --git a/plugins/experimental/money_trace/money_trace.h b/plugins/experimental/money_trace/money_trace.h
new file mode 100644
index 0000000..2c27bdf
--- /dev/null
+++ b/plugins/experimental/money_trace/money_trace.h
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+/*
+ * This plugin looks for range requests and then creates a new
+ * cache key url so that each individual range requests is written
+ * to the cache as a individual object so that subsequent range
+ * requests are read accross different disk drives reducing I/O
+ * wait and load averages when there are large numbers of range
+ * requests.
+ */
+
+#ifndef __MONEY_TRACE_H
+#define __MONEY_TRACE_H
+
+#include <random>
+#include <time.h>
+#include "ts/ts.h"
+#include "ts/remap.h"
+
+#define PLUGIN_NAME "money_trace"
+
+#define LOG_DEBUG(fmt, ...)                                                                  \
+  do {                                                                                       \
+    TSDebug(PLUGIN_NAME, "[%s:%d] %s(): " fmt, __FILE__, __LINE__, __func__, ##__VA_ARGS__); \
+  } while (0)
+
+#define LOG_ERROR(fmt, ...)                                                     \
+  do {                                                                          \
+    TSError("[%s:%d] %s(): " fmt, __FILE__, __LINE__, __func__, ##__VA_ARGS__); \
+  } while (0)
+
+#define MIME_FIELD_MONEY_TRACE "X-MoneyTrace"
+#define MIME_LEN_MONEY_TRACE 12
+
+struct MT {
+  std::minstd_rand0 generator;
+
+  MT() { generator.seed(time(0)); }
+  long
+  spanId()
+  {
+    long v = generator();
+    return (v * v);
+  }
+  const char *moneyTraceHdr(const char *mt_request_hdr);
+};
+
+struct txndata {
+  char *client_request_mt_header;
+  char *new_span_mt_header;
+};
+
+static struct txndata *allocTransactionData();
+static void freeTransactionData(struct txndata *txn_data);
+static void mt_cache_lookup_check(TSCont contp, TSHttpTxn txnp, struct txndata *txn_data);
+static void mt_check_request_header(TSHttpTxn txnp);
+static void mt_send_client_response(TSHttpTxn txnp, struct txndata *txn_data);
+static void mt_send_server_request(TSHttpTxn txnp, struct txndata *txn_data);
+static int transaction_handler(TSCont contp, TSEvent event, void *edata);
+
+#endif
diff --git a/plugins/experimental/remap_stats/remap_stats.c b/plugins/experimental/remap_stats/remap_stats.c
index 8d3f987..dd61935 100644
--- a/plugins/experimental/remap_stats/remap_stats.c
+++ b/plugins/experimental/remap_stats/remap_stats.c
@@ -25,6 +25,7 @@
 #include "ts/ts.h"
 
 #include <stdint.h>
+#include <stdlib.h>
 #include <stdbool.h>
 #include <string.h>
 #include <stdio.h>
diff --git a/plugins/experimental/sslheaders/sslheaders.cc b/plugins/experimental/sslheaders/sslheaders.cc
index 5d77911..ce5ba9e 100644
--- a/plugins/experimental/sslheaders/sslheaders.cc
+++ b/plugins/experimental/sslheaders/sslheaders.cc
@@ -17,12 +17,12 @@
  */
 
 #include "sslheaders.h"
+#include "ink_memory.h"
+
 #include <getopt.h>
 #include <openssl/ssl.h>
 #include <openssl/x509.h>
 
-#include <memory>
-
 static void SslHdrExpand(SSL *, const SslHdrInstance::expansion_list &, TSMBuffer, TSMLoc);
 
 static int
@@ -168,7 +168,7 @@ SslHdrParseOptions(int argc, const char **argv)
 {
   static const struct option longopt[] = {{const_cast<char *>("attach"), required_argument, 0, 'a'}, {0, 0, 0, 0}};
 
-  std::auto_ptr<SslHdrInstance> hdr(new SslHdrInstance());
+  ats_scoped_obj<SslHdrInstance> hdr(new SslHdrInstance());
 
   // We might parse arguments multiple times if we are loaded as a global
   // plugin and a remap plugin. Reset optind so that getopt_long() does the
diff --git a/plugins/experimental/stream_editor/Makefile.am b/plugins/experimental/stream_editor/Makefile.am
new file mode 100644
index 0000000..d2f6968
--- /dev/null
+++ b/plugins/experimental/stream_editor/Makefile.am
@@ -0,0 +1,21 @@
+#  Licensed to the Apache Software Foundation (ASF) under one
+#  or more contributor license agreements.  See the NOTICE file
+#  distributed with this work for additional information
+#  regarding copyright ownership.  The ASF licenses this file
+#  to you under the Apache License, Version 2.0 (the
+#  "License"); you may not use this file except in compliance
+#  with the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+
+include $(top_srcdir)/build/plugins.mk
+
+pkglib_LTLIBRARIES = stream_editor.la
+stream_editor_la_SOURCES = stream_editor.cc
+stream_editor_la_LDFLAGS = $(TS_PLUGIN_LDFLAGS)
diff --git a/plugins/experimental/stream_editor/stream_editor.cc b/plugins/experimental/stream_editor/stream_editor.cc
new file mode 100644
index 0000000..f1bf5a9
--- /dev/null
+++ b/plugins/experimental/stream_editor/stream_editor.cc
@@ -0,0 +1,901 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* stream-editor: apply string and/or regexp search-and-replace to
+ * HTTP request and response bodies.
+ *
+ * Load from plugin.config, with one or more filenames as args.
+ * These are config files, and all config files are equal.
+ *
+ * Each line in a config file and conforming to config syntax specifies a
+ * rule for rewriting input or output.
+ *
+ * A line starting with [out] is an output rule.
+ * One starting with [in] is an input rule.
+ * Any other line is ignored, so blank lines and comments are fine.
+ *
+ * Each line must have a from: field and a to: field specifying what it
+ * rewrites from and to.  Other fields are optional.  The full list:
+ *    from:flags:value
+ *    to:value
+ *    scope:flags:value
+ *    prio:value
+ *    len:value
+ *
+ *   Fields are separated by whitespace.  from: and to: fields may contain
+ *   whitespace if they are quoted.  Quoting may use any non-alphanumeric
+ *   matched-pair delimiter, though the delimiter may not then appear
+ *   (even escaped) within the value string.
+ *
+ *   Flags are:
+ *      i - case-independent matching
+ *      r - regexp match
+ *      u (applies only to scope) - apply scope match to full URI
+ *         starting with "http://" (the default is to match the path
+ *         only, as in for example a <Location> in HTTPD).
+ *
+ *   A from: value is a string or a regexp, according to flags.
+ *   A to: string is a replacement, and may reference regexp memory $1 - $9.
+ *
+ *   A scope: value is likewise a string or (memory-less) regexp and
+ *   determines the scope of URLs over which the rule applies.
+ *
+ *   A prio: value is a single digit, and determines the priority of the
+ *   rule.  That is to say, two or more rules generate overlapping matches,
+ *   the priority value will determine which rule prevails.  A lower
+ *   priority value prevails over a higher one.
+ *
+ *   A len: value is an integer, and applies only to a regexp from:
+ *   It should be an estimate of the largest match size expected from
+ *   the from: pattern.  It is used internally to determine the size of
+ *   a continuity buffer, that avoids missing a match that spans more
+ *   than one incoming data chunk arriving at the stream-editor filter.
+ *   The default is 20.
+ *
+ *   Performance tips:
+ *    - A high len: value on any rule can severely impact on performance,
+ *      especially if mixed with short matches that match frequently.
+ *    - Specify high-precedence rules (low prio: values) first in your
+ *      configuration to avoid reshuffling edits while processing data.
+ *
+ *  Example: a trivial ruleset to escape HTML entities:
+ *   [out] scope::/html-escape/ from::"&" to:"&amp;"
+ *   [out] scope::/html-escape/ from::< to:&lt;
+ *   [out] scope::/html-escape/ from::> to:&gt;
+ *   [out] scope::/html-escape/ from::/"/ to:/&quot;/
+ *   Note, the first & has to be quoted, as the two ampersands in the line
+ *   would otherwise be mis-parsed as a matching pair of delimiters.
+ *   Quoting the &amp;, and the " line with //, are optional (and quoting
+ *   is not applicable to the scope: field).
+ *   The double-colons delimit flags, of which none are used in this example.
+ */
+#define MAX_CONFIG_LINE 1024
+#define MAX_RX_MATCH 10
+#define WHITESPACE " \t\r\n"
+#define PLUGIN_NAME "stream_editor"
+
+#include <stdint.h>
+
+#include <vector>
+#include <set>
+#include <regex.h>
+#include <ctype.h>
+#include <assert.h>
+#include <string.h>
+#include <string>
+#include <stdio.h>
+#include "ts/ts.h"
+
+struct rule_t;
+typedef std::vector<rule_t> ruleset_t;
+typedef ruleset_t::const_iterator rule_p;
+
+typedef struct contdata_t {
+  TSCont cont;
+  TSIOBuffer out_buf;
+  TSIOBufferReader out_rd;
+  TSVIO out_vio;
+  ruleset_t rules;
+  std::string contbuf;
+  size_t contbuf_sz;
+  int64_t bytes_in;
+  int64_t bytes_out;
+  char *query;
+  int query_len;
+  /* Use new/delete so destructor does cleanup for us */
+  contdata_t()
+    : cont(NULL), out_buf(NULL), out_rd(NULL), out_vio(NULL), contbuf_sz(0), bytes_in(0), bytes_out(0), query(NULL), query_len(0)
+  {
+  }
+  ~contdata_t()
+  {
+    if (out_rd)
+      TSIOBufferReaderFree(out_rd);
+    if (out_buf)
+      TSIOBufferDestroy(out_buf);
+    if (cont)
+      TSContDestroy(cont);
+    if (query)
+      TSfree(query);
+  }
+  void
+  set_cont_size(size_t sz)
+  {
+    if (contbuf_sz < 2 * sz)
+      contbuf_sz = 2 * sz - 1;
+  }
+} contdata_t;
+
+
+struct edit_t;
+typedef std::set<edit_t> editset_t;
+typedef editset_t::const_iterator edit_p;
+
+struct edit_t {
+  const size_t start;
+  const size_t bytes;
+  const std::string repl;
+  const int priority;
+  edit_t(size_t s, size_t b, const std::string &r, int p) : start(s), bytes(b), repl(r), priority(p) { ; }
+
+  bool operator!=(const edit_t &x) const
+  {
+    return start != x.start || bytes != x.bytes || repl != x.repl || priority != x.priority;
+  }
+
+  bool operator<(const edit_t &x) const
+  {
+    if ((start == x.start) || (start < x.start && start + bytes > x.start) || (x.start < start && x.start + x.bytes > start)) {
+      /* conflicting edits.  Throw back to resolve conflict */
+      /* Problem: we get called from erase() within conflict resolution,
+       * and comparing to ourself then re-throws.
+       * Need to exclude that case.
+       */
+      if (*this != x)
+        throw x;
+    }
+    return start < x.start;
+  }
+
+  bool
+  saveto(editset_t &edits) const
+  {
+    /* loop to try until inserted or we lose a conflict */
+    for (;;) {
+      try {
+        edits.insert(*this);
+        return true;
+      } catch (const edit_t &conflicted) {
+        TSDebug(PLUGIN_NAME, "Conflicting edits [%ld-%ld] vs [%ld-%ld]", start, start + bytes, conflicted.start,
+                conflicted.start + conflicted.bytes);
+        if (priority < conflicted.priority) {
+          /* we win conflict and oust our enemy */
+          edits.erase(conflicted);
+        } else {
+          /* we lose the conflict - give up */
+          return false;
+        }
+      }
+    }
+  }
+};
+
+
+class scope_t
+{
+  virtual bool match(const char *) const = 0;
+  const bool uri;
+
+public:
+  bool
+  in_scope(TSHttpTxn tx) const
+  {
+    /* Get the URL from tx, and feed it to match() */
+    bool ret = false;
+    TSMBuffer bufp;
+    TSMLoc offset;
+    int length;
+    TSReturnCode rc = TSHttpTxnPristineUrlGet(tx, &bufp, &offset);
+    if (rc != TS_SUCCESS) {
+      TSError("Error getting URL of current Txn");
+      return ret;
+    }
+    char *url = TSUrlStringGet(bufp, offset, &length);
+
+    if (!strncasecmp(url, "https://", 8)) {
+      /* No use trying to edit https data */
+      ret = false;
+    } else {
+      char *p = url;
+      if (uri) {
+        /* match against path component, discard earlier components */
+        if (!strncasecmp(url, "http://", 7)) {
+          p += 7;
+          while (*p != '/') {
+            assert(*p != '\0');
+            ++p;
+          }
+        }
+      }
+      ret = match(p);
+    }
+    TSfree(url);
+    TSHandleMLocRelease(bufp, TS_NULL_MLOC, offset);
+    // TSMBufferDestroy(bufp);
+    return ret;
+  }
+
+  scope_t(const bool u) : uri(u) { ; }
+
+  virtual ~scope_t() {}
+};
+
+
+class rxscope : public scope_t
+{
+private:
+  regex_t rx;
+  virtual bool
+
+  match(const char *str) const
+  {
+    return (regexec(&rx, str, 0, NULL, 0) == 0) ? true : false;
+  }
+
+public:
+  rxscope(const bool u, const bool i, const char *pattern, int len) : scope_t(u)
+  {
+    int flags = REG_NOSUB | REG_EXTENDED | (i ? REG_ICASE : 0);
+    char *str = TSstrndup(pattern, len);
+    int error = regcomp(&rx, str, flags);
+    if (error) {
+      TSError("stream-editor: can't compile regexp [%s]", str);
+      TSfree(str);
+      throw;
+    }
+    TSfree(str);
+  }
+
+  virtual ~rxscope() { regfree(&rx); }
+};
+
+
+class strscope : public scope_t
+{
+private:
+  const bool icase;
+  char *str;
+  virtual bool
+
+  match(const char *p) const
+  {
+    return ((icase ? strncasecmp : strncmp)(str, p, strlen(str)) == 0) ? true : false;
+  }
+
+public:
+  strscope(const bool u, const bool i, const char *pattern, int len) : scope_t(u), icase(i) { str = TSstrndup(pattern, len); }
+
+  virtual ~strscope()
+  {
+    if (str)
+      TSfree(str);
+  }
+};
+
+
+class match_t
+{
+public:
+  virtual bool find(const char *, size_t, size_t &, size_t &, const char *, std::string &, contdata_t *) const = 0;
+  virtual size_t cont_size() const = 0;
+  virtual ~match_t() {}
+};
+
+
+class strmatch : public match_t
+{
+  const bool icase;
+  char *str;
+  const size_t slen;
+
+public:
+  virtual bool
+  find(const char *buf, size_t len, size_t &found, size_t &found_len, const char *to, std::string &repl, contdata_t *cd) const
+  {
+    const char *match = icase ? strcasestr(buf, str) : strstr(buf, str);
+    if (match) {
+      found = match - buf;
+      found_len = slen;
+      repl = to;
+      return (found + slen > len) ? false : true;
+    } else {
+      return false;
+    }
+  }
+
+  strmatch(const bool i, const char *pattern, int len) : icase(i), slen(len) { str = TSstrndup(pattern, len); }
+  virtual ~strmatch()
+  {
+    if (str)
+      TSfree(str);
+  }
+
+  virtual size_t
+  cont_size() const
+  {
+    return slen;
+  }
+};
+
+
+class rxmatch : public match_t
+{
+  size_t match_len;
+  regex_t rx;
+
+public:
+  virtual bool
+  find(const char *buf, size_t len, size_t &found, size_t &found_len, const char *tmpl, std::string &repl, contdata_t *cd) const
+  {
+    regmatch_t pmatch[MAX_RX_MATCH];
+    if (regexec(&rx, buf, MAX_RX_MATCH, pmatch, REG_NOTEOL) == 0) {
+      char c;
+      int n;
+      found = pmatch[0].rm_so;
+      found_len = pmatch[0].rm_eo - found;
+      while (c = *tmpl++, c != '\0') {
+        switch (c) {
+        case '\\':
+          if (*tmpl != '\0') {
+            repl.push_back(*tmpl++);
+          }
+          break;
+        case '$':
+          if (isdigit(*tmpl)) {
+            n = *tmpl - '0';
+          } else if (*tmpl == 'Q') {
+            tmpl++;
+            TSDebug(PLUGIN_NAME, "query = %.*s", cd->query_len, cd->query);
+            repl.append(cd->query, cd->query_len);
+            break;
+          } else {
+            n = MAX_RX_MATCH;
+          }
+          if (n > 0 && n < MAX_RX_MATCH) {
+            repl.append(buf + pmatch[n].rm_so, pmatch[n].rm_eo - pmatch[n].rm_so);
+            tmpl++; /* we've consumed one more character */
+          } else {
+            repl.push_back(c);
+          }
+          break;
+        default:
+          repl.push_back(c);
+          break;
+        }
+      }
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  virtual size_t
+  cont_size() const
+  {
+    return match_len;
+  }
+
+  rxmatch(bool i, const char *pattern, size_t sz, size_t match_max) : match_len(match_max)
+  {
+    char *str = TSstrndup(pattern, sz);
+    int flags = REG_EXTENDED | (i ? REG_ICASE : 0);
+    int error = regcomp(&rx, str, flags);
+    if (error) {
+      TSError("stream-editor: can't compile regexp [%s]", str);
+      TSfree(str);
+      throw;
+    }
+    TSfree(str);
+  }
+
+  virtual ~rxmatch() { regfree(&rx); }
+};
+
+#define PARSE_VERIFY(line, x, str) \
+  while (x)                        \
+    if (!isspace(*(x - 1)))        \
+      x = strcasestr(x + 1, str);  \
+    else                           \
+  break
+
+
+class rule_t
+{
+private:
+  scope_t *scope;
+  unsigned int priority;
+  match_t *from;
+  char *to;
+  int *refcount;
+
+public:
+  rule_t(const char *line) : scope(NULL), priority(5), from(NULL), to(NULL), refcount(NULL)
+  {
+    const char *scope_spec = strcasestr(line, "scope:");
+    const char *from_spec = strcasestr(line, "from:");
+    const char *to_spec = strcasestr(line, "to:");
+    const char *prio_spec = strcasestr(line, "prio:");
+    const char *len_spec = strcasestr(line, "len:");
+    bool icase = false;
+    bool rx = false;
+    bool uri;
+    size_t len, match_len;
+    char delim;
+
+    PARSE_VERIFY(line, scope_spec, "scope:");
+    PARSE_VERIFY(line, from_spec, "from:");
+    PARSE_VERIFY(line, to_spec, "to:");
+    PARSE_VERIFY(line, prio_spec, "prio:");
+    PARSE_VERIFY(line, len_spec, "len:");
+
+    if (!from_spec || !to_spec) {
+      throw "Incomplete stream edit spec";
+    }
+
+    if (len_spec) {
+      match_len = 0;
+      len_spec += 4;
+      while (isdigit(*len_spec)) {
+        match_len = 10 * match_len + (*len_spec++ - '0');
+      }
+    } else {
+      match_len = 20; // default
+    }
+
+    /* parse From: now, as failure could abort constructor */
+    for (from_spec += 5; *from_spec != ':'; ++from_spec) {
+      switch (*from_spec) {
+      case 'i':
+        icase = true;
+        break;
+      case 'r':
+        rx = true;
+        break;
+      }
+    }
+    delim = *++from_spec;
+    if (isalnum(delim)) {
+      len = strcspn(from_spec, WHITESPACE);
+    } else {
+      const char *end = strchr(++from_spec, delim);
+      if (end) {
+        len = end - from_spec;
+      } else {
+        /* it wasn't a delimiter after all */
+        len = strcspn(--from_spec, WHITESPACE);
+      }
+    }
+    if (rx) {
+      from = new rxmatch(icase, from_spec, len, match_len);
+    } else {
+      from = new strmatch(icase, from_spec, len);
+    }
+
+    if (scope_spec) {
+      icase = false;
+      rx = false;
+      uri = true;
+      for (scope_spec += 6; *scope_spec != ':'; ++scope_spec) {
+        switch (*scope_spec) {
+        case 'i':
+          icase = true;
+          break;
+        case 'r':
+          rx = true;
+          break;
+        case 'u':
+          uri = false;
+          break;
+        }
+      }
+      ++scope_spec;
+      len = strcspn(scope_spec, WHITESPACE);
+      if (rx) {
+        scope = new rxscope(uri, icase, scope_spec, len);
+      } else {
+        scope = new strscope(uri, icase, scope_spec, len);
+      }
+    }
+
+    if (prio_spec) {
+      prio_spec += 5;
+      if (isdigit(*prio_spec)) {
+        priority = *prio_spec - '0';
+      }
+    }
+
+    to_spec += 3;
+    delim = *to_spec;
+    if (isalnum(delim)) {
+      len = strcspn(to_spec, WHITESPACE);
+    } else {
+      const char *end = strchr(++to_spec, delim);
+      if (end) {
+        len = end - to_spec;
+      } else {
+        /* it wasn't a delimiter after all */
+        len = strcspn(--to_spec, WHITESPACE);
+      }
+    }
+    to = TSstrndup(to_spec, len);
+
+    refcount = new int(1);
+  }
+
+  rule_t(const rule_t &r) : scope(r.scope), priority(r.priority), from(r.from), to(r.to), refcount(r.refcount) { ++*refcount; }
+  ~rule_t()
+  {
+    if (refcount) {
+      if (!--*refcount) {
+        if (scope)
+          delete scope;
+        if (from)
+          delete from;
+        if (to)
+          TSfree(to);
+        delete refcount;
+      }
+    }
+  }
+
+  bool
+  in_scope(TSHttpTxn tx) const
+  {
+    /* if no scope was specified then everything is in-scope */
+    return scope ? scope->in_scope(tx) : true;
+  }
+
+  size_t
+  cont_size() const
+  {
+    return from->cont_size();
+  }
+
+  void
+  apply(const char *buf, size_t len, editset_t &edits, contdata_t *cd) const
+  {
+    /* find matches in the buf, and add match+replace to edits */
+
+    size_t found;
+    size_t found_len;
+    size_t offs = 0;
+    while (offs < len) {
+      std::string repl;
+      if (from->find(buf + offs, len - offs, found, found_len, to, repl, cd)) {
+        found += offs;
+        edit_t(found, found_len, repl, priority).saveto(edits);
+        offs = found + found_len;
+      } else {
+        break;
+      }
+    }
+  }
+};
+
+static int64_t
+process_block(contdata_t *contdata, TSIOBufferReader reader)
+{
+  int64_t nbytes, start;
+  size_t n = 0;
+  size_t buflen;
+  size_t keep;
+  const char *buf;
+  TSIOBufferBlock block;
+
+  if (reader == NULL) { // We're just flushing anything we have buffered
+    keep = 0;
+    buf = contdata->contbuf.c_str();
+    buflen = contdata->contbuf.length();
+    nbytes = 0;
+  } else {
+    block = TSIOBufferReaderStart(reader);
+    buf = TSIOBufferBlockReadStart(block, reader, &nbytes);
+
+    if (contdata->contbuf.empty()) {
+      /* Use the data as-is */
+      buflen = nbytes;
+    } else {
+      contdata->contbuf.append(buf, nbytes);
+      buf = contdata->contbuf.c_str();
+      buflen = contdata->contbuf.length();
+    }
+    keep = contdata->contbuf_sz;
+  }
+  size_t bytes_read = 0;
+
+  editset_t edits;
+
+  for (rule_p r = contdata->rules.begin(); r != contdata->rules.end(); ++r) {
+    r->apply(buf, buflen, edits, contdata);
+  }
+
+  for (edit_p p = edits.begin(); p != edits.end(); ++p) {
+    /* Preserve continuity buffer */
+    if (p->start >= buflen - keep)
+      break;
+
+    /* pass through bytes before edit */
+    start = p->start - bytes_read;
+
+    while (start > 0) {
+      // FIXME: would this be quicker if we managed a TSIOBuffer
+      //        so we could use TSIOBufferCopy ?
+      n = TSIOBufferWrite(contdata->out_buf, buf + bytes_read, start);
+      assert(n > 0); // FIXME - handle error
+      bytes_read += n;
+      contdata->bytes_out += n;
+      start -= n;
+    }
+
+    /* omit deleted bytes */
+    bytes_read += p->bytes;
+
+    /* insert replacement bytes */
+    n = TSIOBufferWrite(contdata->out_buf, p->repl.c_str(), p->repl.length());
+    assert(n == p->repl.length()); // FIXME (if this ever happens)!
+    contdata->bytes_out += n;
+
+    /* increment counts  - done */
+  }
+  contdata->bytes_in += bytes_read;
+
+  /* data after the last edit */
+  if ((keep <= buflen) && (bytes_read < buflen - keep)) {
+    n = TSIOBufferWrite(contdata->out_buf, buf + bytes_read, buflen - bytes_read - keep);
+    contdata->bytes_in += n;
+    contdata->bytes_out += n;
+    bytes_read += n;
+  }
+  /* reset buf to what we've not processed */
+  contdata->contbuf = buf + bytes_read;
+
+  return nbytes;
+}
+static void
+streamedit_process(TSCont contp)
+{
+  // Read the data available to us
+  // Concatenate with anything we have buffered
+  // Loop over rules, and apply them to build our edit set
+  // Loop over edits, and apply them to the stream
+  // Retain buffered data at the end
+  int64_t ntodo, nbytes;
+  contdata_t *contdata = (contdata_t *)TSContDataGet(contp);
+  TSVIO input_vio = TSVConnWriteVIOGet(contp);
+  TSIOBufferReader input_rd = TSVIOReaderGet(input_vio);
+
+  if (contdata->out_buf == NULL) {
+    contdata->out_buf = TSIOBufferCreate();
+    contdata->out_rd = TSIOBufferReaderAlloc(contdata->out_buf);
+    contdata->out_vio = TSVConnWrite(TSTransformOutputVConnGet(contp), contp, contdata->out_rd, INT64_MAX);
+  }
+
+  TSIOBuffer in_buf = TSVIOBufferGet(input_vio);
+  /* Test for EOS */
+  if (in_buf == NULL) {
+    process_block(contdata, NULL); // flush any buffered data
+    TSVIONBytesSet(contdata->out_vio, contdata->bytes_out);
+    TSVIOReenable(contdata->out_vio);
+    return;
+  }
+
+  /* Test for EOS */
+  ntodo = TSVIONTodoGet(input_vio);
+  if (ntodo == 0) {
+    /* Call back the input VIO continuation to let it know that we
+     * have completed the write operation.
+     */
+    TSContCall(TSVIOContGet(input_vio), TS_EVENT_VCONN_WRITE_COMPLETE, input_vio);
+    TSVIOReenable(contdata->out_vio);
+    return;
+  }
+
+  /* now parse & process buffered data.  We can set some aside
+   * as a continuity buffer to deal with the problem of matches
+   * that span input chunks.
+   */
+  while (ntodo = TSIOBufferReaderAvail(input_rd), ntodo > 0) {
+    nbytes = process_block(contdata, input_rd);
+    TSIOBufferReaderConsume(input_rd, nbytes);
+    TSVIONDoneSet(input_vio, TSVIONDoneGet(input_vio) + nbytes);
+  }
+
+  ntodo = TSVIONTodoGet(input_vio);
+  if (ntodo == 0) {
+    /* Call back the input VIO continuation to let it know that we
+     * have completed the write operation.
+     */
+    TSContCall(TSVIOContGet(input_vio), TS_EVENT_VCONN_WRITE_COMPLETE, input_vio);
+  } else {
+    /* Call back the input VIO continuation to let it know that we
+     * are ready for more data.
+     */
+    TSContCall(TSVIOContGet(input_vio), TS_EVENT_VCONN_WRITE_READY, input_vio);
+  }
+  TSVIOReenable(contdata->out_vio);
+}
+static int
+streamedit_filter(TSCont contp, TSEvent event, void *edata)
+{
+  /* Our main function that does the work.
+   * Called as a continuation for filtering.
+   * *** if necessary, add call at TXN_CLOSE for cleanup.
+   */
+  TSVIO input_vio;
+
+  if (TSVConnClosedGet(contp)) {
+    contdata_t *contdata = (contdata_t *)TSContDataGet(contp);
+    delete contdata;
+    return TS_SUCCESS;
+  }
+
+  switch (event) {
+  case TS_EVENT_ERROR:
+    input_vio = TSVConnWriteVIOGet(contp);
+    TSContCall(TSVIOContGet(input_vio), TS_EVENT_ERROR, input_vio);
+    break;
+  case TS_EVENT_VCONN_WRITE_COMPLETE:
+    TSVConnShutdown(TSTransformOutputVConnGet(contp), 0, 1);
+    break;
+  default:
+    streamedit_process(contp);
+    break;
+  }
+  return TS_SUCCESS;
+}
+
+static int
+streamedit_setup(TSCont contp, TSEvent event, void *edata)
+{
+  TSHttpTxn txn = (TSHttpTxn)edata;
+  ruleset_t *rules_in = (ruleset_t *)TSContDataGet(contp);
+  contdata_t *contdata = NULL;
+
+  assert((event == TS_EVENT_HTTP_READ_RESPONSE_HDR) || (event == TS_EVENT_HTTP_READ_REQUEST_HDR));
+
+  /* make a new list comprising those rules that are in scope */
+  for (rule_p r = rules_in->begin(); r != rules_in->end(); ++r) {
+    if (r->in_scope(txn)) {
+      if (contdata == NULL) {
+        contdata = new contdata_t();
+      }
+      contdata->rules.push_back(*r);
+      contdata->set_cont_size(r->cont_size());
+      TSMBuffer bufp;
+      TSMLoc url_loc = NULL;
+
+      if (TSHttpTxnPristineUrlGet(txn, &bufp, &url_loc) == TS_SUCCESS) {
+        int query_len = 0;
+        const char *query = TSUrlHttpQueryGet(bufp, url_loc, &query_len);
+        contdata->query = TSstrndup(query, query_len);
+        contdata->query_len = query_len;
+      }
+      if (url_loc)
+        TSHandleMLocRelease(bufp, TS_NULL_MLOC, url_loc);
+    }
+  }
+
+  if (contdata == NULL) {
+    /* Nothing to do */
+    TSHttpTxnReenable(txn, TS_EVENT_HTTP_CONTINUE);
+    return TS_SUCCESS;
+  }
+
+  /* we have a job to do, so insert filter */
+  contdata->cont = TSTransformCreate(streamedit_filter, txn);
+  TSContDataSet(contdata->cont, contdata);
+
+  if (event == TS_EVENT_HTTP_READ_REQUEST_HDR) {
+    TSHttpTxnHookAdd(txn, TS_HTTP_REQUEST_TRANSFORM_HOOK, contdata->cont);
+  } else {
+    TSHttpTxnHookAdd(txn, TS_HTTP_RESPONSE_TRANSFORM_HOOK, contdata->cont);
+  }
+
+  TSHttpTxnReenable(txn, TS_EVENT_HTTP_CONTINUE);
+
+  return TS_SUCCESS;
+}
+
+static void
+read_conf(const char *filename, ruleset_t *&in, ruleset_t *&out)
+{
+  char buf[MAX_CONFIG_LINE];
+  FILE *file = fopen(filename, "r");
+
+  if (file == NULL) {
+    TSError("[stream-editor] Failed to open %s", filename);
+    return;
+  }
+  while (fgets(buf, MAX_CONFIG_LINE, file) != NULL) {
+    try {
+      if (!strncasecmp(buf, "[in]", 4)) {
+        if (in == NULL) {
+          in = new ruleset_t();
+        }
+        in->push_back(rule_t(buf));
+      } else if (!strncasecmp(buf, "[out]", 5)) {
+        if (out == NULL) {
+          out = new ruleset_t();
+        }
+        out->push_back(rule_t(buf));
+      }
+    } catch (...) {
+      TSError("stream-editor: failed to parse rule %s", buf);
+    }
+  }
+  fclose(file);
+}
+
+extern "C" void
+TSPluginInit(int argc, const char *argv[])
+{
+  TSPluginRegistrationInfo info;
+  TSCont inputcont, outputcont;
+  ruleset_t *rewrites_in = NULL;
+  ruleset_t *rewrites_out = NULL;
+
+  info.plugin_name = (char *)"stream-editor";
+  info.vendor_name = (char *)"Apache Software Foundation";
+  info.support_email = (char *)"users@trafficserver.apache.org";
+
+  if (TSPluginRegister(TS_SDK_VERSION_3_0, &info) != TS_SUCCESS) {
+    TSError("[stream-editor] Plugin registration failed.");
+    return;
+  }
+
+  /* Allow different config files */
+  while (--argc) {
+    read_conf(*++argv, rewrites_in, rewrites_out);
+  }
+
+  if (rewrites_in != NULL) {
+    TSDebug(PLUGIN_NAME, "initialising input filtering");
+    inputcont = TSContCreate(streamedit_setup, NULL);
+    if (inputcont == NULL) {
+      TSError("[stream-editor] failed to initialise input filtering!");
+    } else {
+      TSContDataSet(inputcont, rewrites_in);
+      TSHttpHookAdd(TS_HTTP_READ_REQUEST_HDR_HOOK, inputcont);
+    }
+  } else {
+    TSDebug(PLUGIN_NAME, "no input filter rules, skipping filter");
+  }
+
+  if (rewrites_out != NULL) {
+    TSDebug(PLUGIN_NAME, "initialising output filtering");
+    outputcont = TSContCreate(streamedit_setup, NULL);
+    if (outputcont == NULL) {
+      TSError("[stream-editor] failed to initialise output filtering!");
+    } else {
+      TSContDataSet(outputcont, rewrites_out);
+      TSHttpHookAdd(TS_HTTP_READ_RESPONSE_HDR_HOOK, outputcont);
+    }
+  } else {
+    TSDebug(PLUGIN_NAME, "no output filter rules, skipping filter");
+  }
+}
diff --git a/plugins/experimental/url_sig/README b/plugins/experimental/url_sig/README
index d2a4ce0..81fdd33 100644
--- a/plugins/experimental/url_sig/README
+++ b/plugins/experimental/url_sig/README
@@ -76,6 +76,27 @@ Signing a URL
 		including "S=".
 		S=<signature>
 
+Signing a URL using path parameters instead of using a query string.
+
+  The parameters above may be embedded in the path part of the request
+  url vs using a query string.  When this method is used, the parameters
+  above are inserted after the path but before the file part of the path
+  in the request url.  Any origin application query parameters then follow
+  the file part of the request and are never part of the sign string.
+
+  Path parameters are separated by a ';' in the path.  The following is an
+  example signed request using the path parameter method and with an origin
+  application query string:
+
+  http://ds-01.comcast.net/vod/t;E=1454013671;A=1;K=3;P=1;S=686945c15e8c4e02146af86a9fd8ee29ff432b0a/Frag10Num10.ts?appid=2&t=1
+
+  Note that the signing parameters are embedded in the path between the last directory part and before the file part of
+  the request.  Using 'parts' in sign.pl, the signature may be signed accordingly up to S= in the above request.  To
+  generate a signed url using this method, use the --pathparams option in sign.pl
+
+
+
+
 
 Example
 	Build, install
@@ -181,3 +202,10 @@ Example
 		{ [data not shown]
 		* Connection #0 to host localhost left intact
 		$
+
+Generating a signed URL with path parameters:
+
+  $ ./sign.pl --url "http://test-remap.domain.com/vod/t/prog_index.m3u8?appid=2&t=1" --useparts 1 --algorithm 1 --duration 86400 --keyindex 3 --key kSCE1_uBREdGI3TPnr_dXKc9f_J4ZV2f --pathparams
+
+  curl -s -o /dev/null -v --max-redirs 0 'http://test-remap.domain.com/vod/t;E=1454015105;A=1;K=3;P=1;S=/173f2ff3667371e666fa17be6c37bfdfe6e89eccprog_index.m3u8?appid=2&t=1'
+
diff --git a/plugins/experimental/url_sig/sign.pl b/plugins/experimental/url_sig/sign.pl
index d3fbdeb..836d7b9 100755
--- a/plugins/experimental/url_sig/sign.pl
+++ b/plugins/experimental/url_sig/sign.pl
@@ -19,6 +19,7 @@
 use Digest::SHA qw(hmac_sha1 hmac_sha1_hex);
 use Digest::HMAC_MD5 qw(hmac_md5 hmac_md5_hex);
 use Getopt::Long;
+use MIME::Base64::URLSafe ();
 use strict;
 use warnings;
 my $key       = undef;
@@ -31,6 +32,10 @@ my $verbose   = 0;
 my $url       = undef;
 my $client    = undef;
 my $algorithm = 1;
+my $pathparams = 0;
+my $sig_anchor = undef;
+my $proxy = undef;
+my $scheme = "http://";
 
 $result = GetOptions(
 	"url=s"       => \$url,
@@ -40,20 +45,63 @@ $result = GetOptions(
 	"client=s"    => \$client,
 	"algorithm=i" => \$algorithm,
 	"keyindex=i"  => \$keyindex,
-	"verbose"     => \$verbose
+	"verbose"     => \$verbose,
+	"pathparams"  => \$pathparams,
+  "proxy=s"     => \$proxy,
+  "siganchor=s"  => \$sig_anchor
 );
 
 if ( !defined($key) || !defined($url) || !defined($duration) || !defined($keyindex) ) {
 	&help();
 	exit(1);
 }
+if ( defined($proxy) ) {
+  if ($proxy  !~ /http\:\/\/.*\:\d\d/) {
+    &help();
+  }
+}
+
+if ($url =~ m/^https/) {
+  $url =~ s/^https:\/\///;
+  $scheme = "https://";
+} else {
+  $url =~ s/^http:\/\///;
+}
 
-$url =~ s/^http:\/\///;
 my $i              = 0;
 my $part_active    = 0;
 my $j              = 0;
 my @inactive_parts = ();
-foreach my $part ( split( /\//, $url ) ) {
+
+my $query_params = undef;
+my $urlHasParams = index($url,"?");
+my $file = undef;
+
+my @parts = (split(/\//, $url));
+my $parts_size = scalar(@parts);
+
+if ($pathparams) {
+  if (scalar(@parts) > 1) {
+    $file = pop @parts;
+  } else {
+    print STDERR "\nERROR: No file segment in the path when using --pathparams.\n\n";
+    &help();
+    exit 1;
+  }
+  if($urlHasParams) {
+    $file = (split(/\?/, $file))[0];
+  }
+  $parts_size = scalar(@parts);
+}
+if ($urlHasParams > 0) {
+  if ( ! $pathparams) {
+    ($parts[$parts_size -1], $query_params) = (split(/\?/, $parts[$parts_size - 1]));
+  } else {
+    $query_params = (split(/\?/, $url))[1];
+  }
+}
+
+foreach my $part (@parts) {
 	if ( length($useparts) > $i ) {
 		$part_active = substr( $useparts, $i++, 1 );
 	}
@@ -65,16 +113,42 @@ foreach my $part ( split( /\//, $url ) ) {
 	}
 	$j++;
 }
+
+my $signing_signature = undef;
+
 chop($string);
-if ( defined($client) ) {
-	$string .= "?C=" . $client . "&E=" . ( time() + $duration ) . "&A=" . $algorithm . "&K=" . $keyindex . "&P=" . $useparts . "&S=";
-}
-else {
-	$string .= "?E=" . ( time() + $duration ) . "&A=" . $algorithm . "&K=" . $keyindex . "&P=" . $useparts . "&S=";
+if ($pathparams) {
+  if ( defined($client) ) {
+    $signing_signature = ";C=" . $client . ";E=" . ( time() + $duration ) . ";A=" . $algorithm . ";K=" . $keyindex . ";P=" . $useparts . ";S=";
+    $string .= $signing_signature;
+  }
+  else {
+    $signing_signature = ";E=" . ( time() + $duration ) . ";A=" . $algorithm . ";K=" . $keyindex . ";P=" . $useparts . ";S=";
+    $string .= $signing_signature;
+  }
+} else {
+  if ( defined($client) ) {
+    if ($urlHasParams > 0) {
+	    $signing_signature = "?$query_params" . "&C=" . $client . "&E=" . ( time() + $duration ) . "&A=" . $algorithm . "&K=" . $keyindex . "&P=" . $useparts . "&S=";
+      $string .= $signing_signature;
+    }
+    else {
+	    $signing_signature = "?C=" . $client . "&E=" . ( time() + $duration ) . "&A=" . $algorithm . "&K=" . $keyindex . "&P=" . $useparts . "&S=";
+      $string .= $signing_signature;
+    }
+  }
+  else {
+    if ($urlHasParams > 0) {
+	    $signing_signature = "?$query_params" . "&E=" . ( time() + $duration ) . "&A=" . $algorithm . "&K=" . $keyindex . "&P=" . $useparts . "&S=";
+      $string .= $signing_signature;
+    }
+    else {
+	    $signing_signature = "?E=" . ( time() + $duration ) . "&A=" . $algorithm . "&K=" . $keyindex . "&P=" . $useparts . "&S=";
+      $string .= $signing_signature;
+    }
+  }
 }
 
-$verbose && print "signed string = " . $string . "\n";
-
 my $digest;
 if ( $algorithm == 1 ) {
 	$digest = hmac_sha1_hex( $string, $key );
@@ -82,9 +156,75 @@ if ( $algorithm == 1 ) {
 else {
 	$digest = hmac_md5_hex( $string, $key );
 }
-my $qstring = ( split( /\?/, $string ) )[1];
 
-print "curl -s -o /dev/null -v --max-redirs 0 'http://" . $url . "?" . $qstring . $digest . "'\n";
+$verbose && print "\nSigned String: $string\n\n";
+$verbose && print "\nUrl: $url\n";
+$verbose && print "\nsigning_signature: $signing_signature\n";
+$verbose && print "\ndigest: $digest\n";
+
+if ($urlHasParams == -1) { # no application query parameters.
+    if ( ! defined($proxy)) {
+      if ( ! $pathparams) {
+        print "curl -s -o /dev/null -v --max-redirs 0 '$scheme" . $url . $signing_signature . $digest . "'\n\n";
+      } else {
+        my $index = rindex($url, '/');
+        $url = substr($url,0,$index);
+        my $encoded = MIME::Base64::URLSafe::encode($signing_signature . $digest);
+        if (defined($sig_anchor)) {
+          print "curl -s -o /dev/null -v --max-redirs 0 '$scheme" . $url . ";${sig_anchor}=" . $encoded . "/$file" . "'\n\n";
+        } else {
+          print "curl -s -o /dev/null -v --max-redirs 0 '$scheme" . $url . "/" . $encoded . "/$file" . "'\n\n";
+        }
+      }
+    } else {
+      if ( ! $pathparams) {
+        print "curl -s -o /dev/null -v --max-redirs 0 --proxy $proxy '$scheme" . $url . $signing_signature . $digest .
+          "'\n\n";
+      } else {
+        my $index = rindex($url, '/');
+        $url = substr($url,0,$index);
+        my $encoded = MIME::Base64::URLSafe::encode($signing_signature . $digest);
+        if (defined($sig_anchor)) {
+          print "curl -s -o /dev/null -v --max-redirs 0 --proxy $proxy '$scheme" . $url . ";${sig_anchor}=" . $encoded .  "/$file" . "'\n\n";
+        } else {
+          print "curl -s -o /dev/null -v --max-redirs 0 --proxy $proxy '$scheme" . $url . "/" . $encoded .  "/$file" . "'\n\n";
+        }
+      }
+    }
+} else { # has application parameters.
+    $url = (split(/\?/, $url))[0];
+    if ( ! defined($proxy)) {
+      if ( ! $pathparams) {
+        print "curl -s -o /dev/null -v --max-redirs 0 '$scheme" . $url . $signing_signature . $digest . "'\n\n";
+      } else {
+        my $index = rindex($url, '/');
+        $url = substr($url,0,$index);
+        my $encoded = MIME::Base64::URLSafe::encode($signing_signature . $digest);
+        if (defined($sig_anchor)) {
+          print "curl -s -o /dev/null -v --max-redirs 0 '$scheme" . $url . ";${sig_anchor}=" . $encoded  . "/" . $file . "?$query_params"
+          . "'\n\n";
+        } else {
+          print "curl -s -o /dev/null -v --max-redirs 0 '$scheme" . $url . "/" . $encoded  . "/" . $file . "?$query_params"
+          . "'\n\n";
+        }
+      }
+    } else {
+      if ( ! $pathparams) {
+        print "curl -s -o /dev/null -v --max-redirs 0 --proxy $proxy '$scheme" . $url . $signing_signature . $digest .
+         "'\n\n";
+      } else {
+        my $index = rindex($url, '/');
+        $url = substr($url,0,$index);
+        my $encoded = MIME::Base64::URLSafe::encode($signing_signature . $digest);
+        if (defined($sig_anchor)) {
+          print "curl -s -o /dev/null -v --max-redirs 0 --proxy $proxy '$scheme" . $url . ";${sig_anchor}=" . $encoded  . "/" . $file . "?$query_params"
+          . "'\n\n";
+        } else {
+          print "curl -s -o /dev/null -v --max-redirs 0 --proxy $proxy '$scheme" . $url . "/" . $encoded .  "/$file?$query_params" . "'\n\n";
+        }
+      }
+    }
+}
 
 sub help {
 	print "sign.pl - Example signing utility in perl for signed URLs\n";
@@ -97,5 +237,7 @@ sub help {
 	print "             [--client <value>] \\ \n";
 	print "             --key <value>  \\ \n";
 	print "             [--verbose] \n";
+	print "             [--pathparams] \n";
+	print "             [--proxy <url:port value>] ex value: http://myproxy:80\n";
 	print "\n";
 }
diff --git a/plugins/experimental/url_sig/url_sig.c b/plugins/experimental/url_sig/url_sig.c
index 2418f21..baf381f 100644
--- a/plugins/experimental/url_sig/url_sig.c
+++ b/plugins/experimental/url_sig/url_sig.c
@@ -31,6 +31,7 @@
 #include <arpa/inet.h>
 #include <limits.h>
 #include <ctype.h>
+#include <stdbool.h>
 
 #ifdef HAVE_PCRE_PCRE_H
 #include <pcre/pcre.h>
@@ -49,6 +50,7 @@ struct config {
   char keys[MAX_KEY_NUM][MAX_KEY_LEN];
   pcre *regex;
   pcre_extra *regex_extra;
+  char *sig_anchor;
 };
 
 static void
@@ -56,6 +58,7 @@ free_cfg(struct config *cfg)
 {
   TSError("Cleaning up...");
   TSfree(cfg->err_url);
+  TSfree(cfg->sig_anchor);
 
   if (cfg->regex_extra)
 #ifndef PCRE_STUDY_JIT_COMPILE
@@ -173,6 +176,9 @@ TSRemapNewInstance(int argc, char *argv[], void **ih, char *errbuf, int errbuf_s
         cfg->err_url = TSstrndup(value, strlen(value));
       else
         cfg->err_url = NULL;
+    } else if (strncmp(line, "sig_anchor", 10) == 0) { 
+        cfg->sig_anchor = TSstrndup(value, strlen(value));
+        TSDebug(PLUGIN_NAME, "sig_anchor: %s", cfg->sig_anchor);
     } else if (strncmp(line, "excl_regex", 10) == 0) {
       // compile and study regex
       const char *errptr;
@@ -245,6 +251,174 @@ err_log(char *url, char *msg)
   }
 }
 
+static char *
+getAppQueryString(char *query_string, int query_length)
+{
+  int done = 0;
+  char *p;
+  char buf[4096];
+
+  memset(buf, 0, 4096);
+  strncpy(buf, query_string, query_length);
+  p = buf;
+
+  TSDebug(PLUGIN_NAME, "query_string: %s, query_length: %d", query_string, query_length);
+  if (p == NULL) {
+    return NULL;
+  }
+
+  do {
+    switch (*p) {
+    case 'A':
+    case 'C':
+    case 'E':
+    case 'K':
+    case 'P':
+    case 'S':
+      done = 1;
+      if (*(p - 1) == '&') {
+        *(p - 1) = '\0';
+      } else
+        (*p = '\0');
+      break;
+    default:
+      p = strchr(p, '&');
+      if (p == NULL)
+        done = 1;
+      else
+        p++;
+      break;
+    }
+  } while (!done);
+
+  if (strlen(buf) > 0) {
+    p = TSstrdup(buf);
+    return p;
+  } else {
+    return NULL;
+  }
+}
+
+static char *
+urlParse(bool *https, char *anchor, char *url, char *new_path_seg, int new_path_seg_len, char *signed_seg, int signed_seg_len)
+{
+  char *segment[MAX_SEGMENTS];
+  unsigned char decoded_string[2048] = {'\0'};
+  char new_url[8192] = {'\0'};
+  char *p = NULL, *sig_anchor = NULL, *saveptr = NULL;
+  int i = 0, numtoks = 0, cp_len = 0, l, decoded_len = 0, sig_anchor_seg = 0;
+
+  // parse the url.
+  if ((p = strtok_r(url, "/", &saveptr)) != NULL) {
+    segment[numtoks++] = p;
+    do {
+      p = strtok_r(NULL, "/", &saveptr);
+      if (p != NULL) {
+        segment[numtoks] = p;
+        if (anchor != NULL && sig_anchor_seg == 0) {
+          // look for the signed anchor string.
+          if ((sig_anchor = strcasestr(segment[numtoks],anchor)) != NULL) {
+            // null terminate this segment just before he signing anchor, this should be a ';'.
+            *(sig_anchor - 1) = '\0';
+            if ((sig_anchor = strstr(sig_anchor, "=")) != NULL) {
+              *sig_anchor = '\0';
+              sig_anchor++;
+              sig_anchor_seg = numtoks;
+            }
+          }
+        }
+        numtoks++;
+      }
+    } while (p != NULL && numtoks < MAX_SEGMENTS);
+  } else {
+    return NULL;
+  }
+  if ((numtoks >= MAX_SEGMENTS) || (numtoks < 3)) {
+    return NULL;
+  }
+
+  // create a new path string for later use when dealing with query parameters.
+  // this string will not contain the signing parameters.  skips the scheme
+  // and fqdn by starting with 2.
+  for (i = 2; i < numtoks; i++) {
+    // if no signing anchor is found, skip the signed parameters segment.
+    if (sig_anchor == NULL && i == numtoks - 2) {
+      // the signing parameters when no signature anchor is found, should be in the 
+      // last path segment so skip them.
+      continue;
+    }
+    l = strlen(segment[i]);
+    if (l + 1 > new_path_seg_len) {
+      TSError("insuficient space to copy into new_path_seg buffer.");
+      return NULL;
+    } else {
+      strncat(new_path_seg, segment[i], l);
+      if (i != numtoks - 1) {
+        strncat(new_path_seg, "/", 1);
+      }
+      cp_len += l + 1;
+    }
+  }
+  TSDebug(PLUGIN_NAME, "new_path_seg: %s", new_path_seg);
+
+  // save the encoded signing parameter data
+  if (sig_anchor != NULL) { // a signature anchor string was found.
+    if (strlen(sig_anchor) < signed_seg_len) {
+      strncpy(signed_seg, sig_anchor, strlen(sig_anchor));
+    } else {
+      TSError("insuficient space to copy into new_path_seg buffer.");
+    }
+  } else { // no signature anchor string was found, assum it is in the last path segment.
+    if (strlen(segment[numtoks - 2]) < signed_seg_len) {
+      strncpy(signed_seg, segment[numtoks - 2], strlen(segment[numtoks - 2]));
+    } else {
+      TSError("insuficient space to copy into new_path_seg buffer.");
+      return NULL;
+    }
+  }
+  TSDebug(PLUGIN_NAME, "signed_seg: %s", signed_seg);
+
+  // no signature anchor was found so decode and save the signing parameters assumed
+  // to be in the last path segment.
+  if (sig_anchor == NULL) {
+    if (TSBase64Decode(segment[numtoks - 2], strlen(segment[numtoks - 2]), decoded_string, sizeof(decoded_string),
+                      (size_t *)&decoded_len) != TS_SUCCESS) {
+      TSDebug(PLUGIN_NAME, "Unable to decode the  path parameter string.");
+    }
+  } else {
+    if (TSBase64Decode(sig_anchor, strlen(sig_anchor), decoded_string, sizeof(decoded_string),
+                      (size_t *)&decoded_len) != TS_SUCCESS) {
+      TSDebug(PLUGIN_NAME, "Unable to decode the  path parameter string.");
+    }
+  }
+  TSDebug(PLUGIN_NAME, "decoded_string: %s", decoded_string);
+
+  if (https) {
+    strncat(new_url, "https://", 8);
+  } else {
+    strncat(new_url, "http://", 7);
+  }
+
+  for (i = 1; i < numtoks; i++) {
+    // cp the base64 decoded string.
+    if (i == sig_anchor_seg && sig_anchor != NULL) {
+      strncat(new_url, segment[i], strlen(segment[i]));
+      strncat(new_url, (char *)decoded_string, strlen((char *)decoded_string));
+      strncat(new_url, "/", 1);
+      continue;
+    } else if (i == numtoks - 2 && sig_anchor == NULL) {
+      strncat(new_url, (char *)decoded_string, strlen((char *)decoded_string));
+      strncat(new_url, "/", 1);
+      continue;
+    }
+    strncat(new_url, segment[i], strlen(segment[i]));
+    if (i < numtoks - 1) { 
+      strncat(new_url, "/", 1);
+    }
+  }
+  return TSstrndup(new_url, strlen(new_url));
+}
+
 TSRemapStatus
 TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo *rri)
 {
@@ -261,12 +435,19 @@ TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo *rri)
   int j = 0;
   unsigned int sig_len = 0;
 
+  bool has_path_params = false;
+  bool https_scheme = false;
+  bool isClient_ipv6 = false;
+
   /* all strings are locally allocated except url... about 25k per instance */
-  char *url;
+  char *url, *new_url;
+  char path_params[8192] = {'\0'}, new_path[8192] = {'\0'};
   char signed_part[8192] = {'\0'}; // this initializes the whole array and is needed
   char urltokstr[8192] = {'\0'};
-  char client_ip[CIP_STRLEN] = {'\0'};
-  char ipstr[CIP_STRLEN] = {'\0'};
+  char client_ipv4[INET_ADDRSTRLEN] = {'\0'};
+  char ipstr_v4[INET_ADDRSTRLEN] = {'\0'};
+  char client_ipv6[INET6_ADDRSTRLEN] = {'\0'};
+  char ipstr_v6[INET6_ADDRSTRLEN] = {'\0'};
   unsigned char sig[MAX_SIG_SIZE + 1];
   char sig_string[2 * MAX_SIG_SIZE + 1];
 
@@ -275,11 +456,7 @@ TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo *rri)
   char *parts = NULL;
   char *part = NULL;
   char *p = NULL, *pp = NULL;
-  char *query = NULL;
-
-  int retval, sockfd;
-  socklen_t peer_len;
-  struct sockaddr_in peer;
+  char *query = NULL, *app_qry = NULL;
 
   url = TSUrlStringGet(rri->requestBufp, rri->requestUrl, &url_len);
 
@@ -288,7 +465,7 @@ TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo *rri)
     goto deny;
   }
 
-  TSDebug(PLUGIN_NAME, "%s", url);
+  TSDebug(PLUGIN_NAME, "url: %s", url);
 
   query = strstr(url, "?");
 
@@ -309,49 +486,88 @@ TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo *rri)
     }
   }
 
-  if (query == NULL) {
-    err_log(url, "Has no query string.");
-    goto deny;
+  // check for path params.
+  if (query == NULL || strstr(query, "E=") == NULL) {
+    if ((new_url = urlParse(&https_scheme, cfg->sig_anchor, url, new_path, 8192, path_params, 8192)) == NULL) {
+      err_log(url, "Has no signing query string or signing path parameters.");
+      goto deny;
+    }
+    TSDebug(PLUGIN_NAME, "new_url: %s", new_url);
+    has_path_params = true;
+    TSfree(url);
+    url = new_url;
+    query = strstr(url, ";");
+
+    if (query == NULL) {
+      err_log(url, "Has no signing query string or signing path parameters.");
+      goto deny;
+    }
   }
 
-  if (strncmp(url, "http://", strlen("http://")) != 0) {
-    err_log(url, "Invalid URL scheme - only http supported.");
-    goto deny;
+  if (strncmp(url, "https://", strlen("https://")) == 0) {
+    https_scheme = true;
   }
 
   /* first, parse the query string */
-  query++; /* get rid of the ? */
+  if (!has_path_params) {
+    query++; /* get rid of the ? */
+  }
   TSDebug(PLUGIN_NAME, "Query string is:%s", query);
 
   // Client IP - this one is optional
   p = strstr(query, CIP_QSTRING "=");
   if (p != NULL) {
-    p += strlen(CIP_QSTRING + 1);
-    pp = strstr(p, "&");
-    if ((pp - p) > CIP_STRLEN - 1 || (pp - p) < 4) {
-      err_log(url, "IP address string too long or short.");
-      goto deny;
-    }
-    strncpy(client_ip, p + strlen(CIP_QSTRING) + 1, (pp - p - (strlen(CIP_QSTRING) + 1)));
-    client_ip[pp - p - (strlen(CIP_QSTRING) + 1)] = '\0';
-    TSDebug(PLUGIN_NAME, "CIP: -%s-", client_ip);
-    retval = TSHttpTxnClientFdGet(txnp, &sockfd);
-    if (retval != TS_SUCCESS) {
-      err_log(url, "Error getting sockfd.");
-      goto deny;
-    }
-    peer_len = sizeof(peer);
-    if (getpeername(sockfd, (struct sockaddr *)&peer, &peer_len) != 0) {
-      perror("Can't get peer address:");
-    }
-    struct sockaddr_in *s = (struct sockaddr_in *)&peer;
-    inet_ntop(AF_INET, &s->sin_addr, ipstr, sizeof ipstr);
-    TSDebug(PLUGIN_NAME, "Peer address: -%s-", ipstr);
-    if (strcmp(ipstr, client_ip) != 0) {
-      err_log(url, "Client IP doesn't match signature.");
+    p += (strlen(CIP_QSTRING) + 1);
+    struct sockaddr const *ip = TSHttpTxnClientAddrGet(txnp); 
+    if (ip == NULL) {
+      TSError("Can't get client ip address.");
       goto deny;
+    } else {
+      switch (ip->sa_family) {
+        case AF_INET:
+          TSDebug(PLUGIN_NAME, "ip->sa_family: AF_INET");
+          isClient_ipv6 = false;
+          has_path_params == false ? (pp = strstr(p, "&")) : (pp = strstr(p, ";"));
+          if ((pp - p) > INET_ADDRSTRLEN - 1 || (pp - p) < 4) {
+            err_log(url, "IP address string too long or short.");
+            goto deny;
+          }
+          strncpy(client_ipv4, p, (pp - p));
+          client_ipv4[pp - p] = '\0';
+          TSDebug(PLUGIN_NAME, "CIP: -%s-", client_ipv4);
+          inet_ntop(AF_INET, &(((struct sockaddr_in *)ip)->sin_addr), ipstr_v4, sizeof ipstr_v4);
+          TSDebug(PLUGIN_NAME, "Peer address: -%s-", ipstr_v4);
+          if (strcmp(ipstr_v4, client_ipv4) != 0) {
+            err_log(url, "Client IP doesn't match signature.");
+            goto deny;
+          }
+          break;
+        case AF_INET6:
+          TSDebug(PLUGIN_NAME, "ip->sa_family: AF_INET6");
+          isClient_ipv6 = true;
+          has_path_params == false ? (pp = strstr(p, "&")) : (pp = strstr(p, ";"));
+          if ((pp - p) > INET6_ADDRSTRLEN - 1 || (pp - p) < 4) {
+            err_log(url, "IP address string too long or short.");
+            goto deny;
+          }
+          strncpy(client_ipv6, p, (pp - p));
+          client_ipv6[pp - p] = '\0';
+          TSDebug(PLUGIN_NAME, "CIP: -%s-", client_ipv6);
+          inet_ntop(AF_INET6, &(((struct sockaddr_in6 *)ip)->sin6_addr), ipstr_v6, sizeof ipstr_v6);
+          TSDebug(PLUGIN_NAME, "Peer address: -%s-", ipstr_v6);
+          if (strcmp(ipstr_v6, client_ipv6) != 0) {
+            err_log(url, "Client IP doesn't match signature.");
+            goto deny;
+          }
+          break;
+        default:
+          TSError("%s: Unknown address family %d", PLUGIN_NAME, ip->sa_family);
+          goto deny;
+          break;
+      }
     }
   }
+
   // Expiration
   p = strstr(query, EXP_QSTRING "=");
   if (p != NULL) {
@@ -396,7 +612,7 @@ TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo *rri)
   if (p != NULL) {
     p += strlen(PAR_QSTRING) + 1;
     parts = p; // NOTE parts is not NULL terminated it is terminated by "&" of next param
-    p = strstr(parts, "&");
+    has_path_params == false ? (p = strstr(parts, "&")) : (p = strstr(parts, ";"));
     TSDebug(PLUGIN_NAME, "Parts: %.*s", (int)(p - parts), parts);
   } else {
     err_log(url, "PartsSigned query string not found.");
@@ -418,12 +634,20 @@ TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo *rri)
   }
 
   /* have the query string, and parameters passed initial checks */
-  TSDebug(PLUGIN_NAME, "Found all needed parameters: C=%s E=%d A=%d K=%d P=%s S=%s", client_ip, (int)expiration, algorithm,
+  if (isClient_ipv6 == true) {
+    TSDebug(PLUGIN_NAME, "Found all needed parameters: C=%s E=%d A=%d K=%d P=%s S=%s", client_ipv6, (int)expiration, algorithm,
+            keyindex, parts, signature);
+  } else {
+    TSDebug(PLUGIN_NAME, "Found all needed parameters: C=%s E=%d A=%d K=%d P=%s S=%s", client_ipv4, (int)expiration, algorithm,
           keyindex, parts, signature);
-
+  }
   /* find the string that was signed - cycle through the parts letters, adding the part of the fqdn/path if it is 1 */
-  p = strstr(url, "?");
-  memcpy(urltokstr, &url[strlen("http://")], p - url - strlen("http://"));
+  has_path_params == false ? (p = strstr(url, "?")) : (p = strstr(url, ";"));
+  if (https_scheme) {
+    memcpy(urltokstr, &url[strlen("https://")], p - url - strlen("https://"));
+  } else {
+    memcpy(urltokstr, &url[strlen("http://")], p - url - strlen("http://"));
+  }
   part = strtok_r(urltokstr, "/", &p);
   while (part != NULL) {
     if (parts[j] == '1') {
@@ -436,8 +660,10 @@ TSRemapDoRemap(void *ih, TSHttpTxn txnp, TSRemapRequestInfo *rri)
     part = strtok_r(NULL, "/", &p);
   }
 
-  signed_part[strlen(signed_part) - 1] = '?'; // chop off the last /, replace with '?'
+  // chop off the last /, replace with '?' or ';' as appropriate.
+  has_path_params == false ? (signed_part[strlen(signed_part) - 1] = '?') : (signed_part[strlen(signed_part) - 1] = '\0');
   p = strstr(query, SIG_QSTRING "=");
+  TSDebug(PLUGIN_NAME, "p: %s, query: %s, signed_part: %s", p, query, signed_part);
   strncat(signed_part, query, (p - query) + strlen(SIG_QSTRING) + 1);
 
   TSDebug(PLUGIN_NAME, "Signed string=\"%s\"", signed_part);
@@ -510,11 +736,33 @@ deny:
 
 /* ********* Allow ********* */
 allow:
+  TSDebug(PLUGIN_NAME, "URL: %s", url);
+  query = strstr(url, "?");
+  // app query parameters aren't affected if we've used signed path params.
+  if (query != NULL && !has_path_params) {
+    query++; // get rid of the '?'
+    app_qry = getAppQueryString(query, strlen(query));
+  }
+  TSDebug(PLUGIN_NAME, "has_path_params: %d", has_path_params);
+  if (has_path_params) {
+    if (*new_path) {
+      TSUrlPathSet(rri->requestBufp, rri->requestUrl, new_path, strlen(new_path));
+    }
+    TSUrlHttpParamsSet(rri->requestBufp, rri->requestUrl, NULL, 0);
+  }
+
   TSfree(url);
-  /* drop the query string so we can cache-hit */
-  rval = TSUrlHttpQuerySet(rri->requestBufp, rri->requestUrl, NULL, 0);
+  if (app_qry != NULL) {
+    rval = TSUrlHttpQuerySet(rri->requestBufp, rri->requestUrl, app_qry, strlen(app_qry));
+    TSfree(app_qry);
+  } else {
+    rval = TSUrlHttpQuerySet(rri->requestBufp, rri->requestUrl, NULL, 0);
+  }
   if (rval != TS_SUCCESS) {
-    TSError("Error stripping query string: %d.", rval);
+    TSError("Error setting the query string: %d.", rval);
   }
+  url = TSUrlStringGet(rri->requestBufp, rri->requestUrl, &url_len);
+  TSDebug(PLUGIN_NAME, "url: %s", url);
+
   return TSREMAP_NO_REMAP;
 }
diff --git a/plugins/experimental/url_sig/url_sig.h b/plugins/experimental/url_sig/url_sig.h
index 6e22600..95d3df8 100644
--- a/plugins/experimental/url_sig/url_sig.h
+++ b/plugins/experimental/url_sig/url_sig.h
@@ -31,10 +31,10 @@
   "S" /* S=9e2828d570a4bee3c964f698b0985ee58b9f6b64 means 9e2828d570a4bee3c964f698b0985ee58b9f6b64 is the sig \
          This one has to be the last one of the string */
 
-#define CIP_STRLEN 20
 #define EXP_STRLEN 16
 #define PAR_STRLEN 16
 #define MAX_PARTS 32
+#define MAX_SEGMENTS 64
 
 #define MAX_HTTP_REQUEST_SIZE 8192 //
 
diff --git a/proxy/IPAllow.h b/proxy/IPAllow.h
index a9fa1cf..fc7d5d2 100644
--- a/proxy/IPAllow.h
+++ b/proxy/IPAllow.h
@@ -43,13 +43,6 @@
 // forward declare in name only so it can be a friend.
 struct IpAllowUpdate;
 
-//
-// Timeout the IpAllowTable * this amount of time after the
-//    a reconfig event happens that the old table gets thrown
-//    away
-//
-static uint64_t const IP_ALLOW_TIMEOUT = HRTIME_HOUR;
-
 /** An access control record.
     It has the methods permitted and the source line.
 */
diff --git a/proxy/InkAPI.cc b/proxy/InkAPI.cc
index eb230fa..4e4970b 100644
--- a/proxy/InkAPI.cc
+++ b/proxy/InkAPI.cc
@@ -4603,8 +4603,14 @@ TSHttpTxnPristineUrlGet(TSHttpTxn txnp, TSMBuffer *bufp, TSMLoc *url_loc)
     *(reinterpret_cast<HTTPHdr **>(bufp)) = hptr;
     *url_loc = (TSMLoc)sm->t_state.pristine_url.m_url_impl;
 
-    if ((sdk_sanity_check_mbuffer(*bufp) == TS_SUCCESS) && (*url_loc))
-      return TS_SUCCESS;
+    if (sdk_sanity_check_mbuffer(*bufp) == TS_SUCCESS) {
+      if (*url_loc == NULL) {
+        *url_loc = (TSMLoc)hptr->m_http->u.req.m_url_impl;
+      }
+      if (*url_loc) {
+        return TS_SUCCESS;
+      }
+    }
   }
   return TS_ERROR;
 }
diff --git a/proxy/InkAPITest.cc b/proxy/InkAPITest.cc
index e0ecad1..967cf11 100644
--- a/proxy/InkAPITest.cc
+++ b/proxy/InkAPITest.cc
@@ -7210,7 +7210,7 @@ const char *SDK_Overridable_Configs[TS_CONFIG_LAST_ENTRY] = {
   "proxy.config.http.parent_proxy.per_parent_connect_attempts", "proxy.config.http.parent_proxy.total_connect_attempts",
   "proxy.config.http.parent_origin.simple_retry_enabled", "proxy.config.http.parent_origin.simple_retry_response_codes",
   "proxy.config.http.parent_origin.dead_server_retry_enabled", "proxy.config.http.parent_origin.dead_server_retry_response_codes",
-  "proxy.config.http.url_remap.remap_required"};
+  "proxy.config.url_remap.remap_required"};
 
 REGRESSION_TEST(SDK_API_OVERRIDABLE_CONFIGS)(RegressionTest *test, int /* atype ATS_UNUSED */, int *pstatus)
 {
diff --git a/proxy/Main.cc b/proxy/Main.cc
index 424f1e8..3310c01 100644
--- a/proxy/Main.cc
+++ b/proxy/Main.cc
@@ -1000,6 +1000,8 @@ adjust_sys_settings(void)
       fds_limit = (int)lim.rlim_cur;
       syslog(LOG_NOTICE, "NOTE: RLIMIT_NOFILE(%d):cur(%d),max(%d)", RLIMIT_NOFILE, (int)lim.rlim_cur, (int)lim.rlim_max);
     }
+  } else {
+    syslog(LOG_NOTICE, "NOTE: Could not read sys.fs.file-max");
   }
 
   REC_ReadConfigInteger(fds_throttle, "proxy.config.net.connections_throttle");
diff --git a/proxy/Makefile.am b/proxy/Makefile.am
index 505fc56..17711e0 100644
--- a/proxy/Makefile.am
+++ b/proxy/Makefile.am
@@ -166,6 +166,10 @@ traffic_server_SOURCES = \
   Main.h \
   ParentSelection.cc \
   ParentSelection.h \
+	ParentConsistentHash.cc \
+	ParentConsistentHash.h \
+	ParentRoundRobin.cc \
+	ParentRoundRobin.h \
   Plugin.cc \
   Plugin.h \
   PluginVC.cc \
@@ -283,6 +287,8 @@ traffic_sac_SOURCES = \
   ICPStats.cc \
   IPAllow.cc \
   ParentSelection.cc \
+  ParentConsistentHash.cc \
+  ParentRoundRobin.cc \
   ControlBase.cc \
   ControlMatcher.cc \
   CacheControl.cc \
diff --git a/proxy/ParentConsistentHash.cc b/proxy/ParentConsistentHash.cc
new file mode 100644
index 0000000..1171ab9
--- /dev/null
+++ b/proxy/ParentConsistentHash.cc
@@ -0,0 +1,333 @@
+/** @file
+
+  Implementation of Parent Proxy routing
+
+  @section license License
+
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+ */
+#include "ParentConsistentHash.h"
+
+ParentConsistentHash::ParentConsistentHash(ParentRecord *parent_record)
+{
+  int i;
+
+  ink_assert(parent_record->num_parents > 0);
+  parents[PRIMARY] = parent_record->parents;
+  parents[SECONDARY] = parent_record->secondary_parents;
+  ignore_query = parent_record->ignore_query;
+  ink_zero(foundParents);
+
+  chash[PRIMARY] = new ATSConsistentHash();
+
+  for (i = 0; i < parent_record->num_parents; i++) {
+    chash[PRIMARY]->insert(&(parent_record->parents[i]), parent_record->parents[i].weight, (ATSHash64 *)&hash[PRIMARY]);
+  }
+
+  if (parent_record->num_secondary_parents > 0) {
+    Debug("parent_select", "ParentConsistentHash(): initializing the secondary parents hash.");
+    chash[SECONDARY] = new ATSConsistentHash();
+
+    for (i = 0; i < parent_record->num_secondary_parents; i++) {
+      chash[SECONDARY]->insert(&(parent_record->secondary_parents[i]), parent_record->secondary_parents[i].weight,
+                               (ATSHash64 *)&hash[SECONDARY]);
+    }
+  } else {
+    chash[SECONDARY] = NULL;
+  }
+  last_unavailable = time(NULL);
+
+  Debug("parent_select", "Using a consistent hash parent selection strategy.");
+}
+
+ParentConsistentHash::~ParentConsistentHash()
+{
+  delete chash[PRIMARY];
+  delete chash[SECONDARY];
+}
+
+
+uint64_t
+ParentConsistentHash::getPathHash(HttpRequestData *hrdata, ATSHash64 *h)
+{
+  const char *tmp = NULL;
+  int len;
+  URL *url = hrdata->hdr->url_get();
+
+  // Always hash on '/' because paths returned by ATS are always stripped of it
+  h->update("/", 1);
+
+  tmp = url->path_get(&len);
+  if (tmp) {
+    h->update(tmp, len);
+  }
+
+  if (!ignore_query) {
+    tmp = url->query_get(&len);
+    if (tmp) {
+      h->update("?", 1);
+      h->update(tmp, len);
+    }
+  }
+
+  h->final();
+
+  return h->get();
+}
+
+void
+ParentConsistentHash::selectParent(const ParentSelectionPolicy *policy, bool first_call, ParentResult *result, RequestData *rdata)
+{
+  ATSHash64Sip24 hash;
+  ATSConsistentHash *fhash;
+  HttpRequestData *request_info = static_cast<HttpRequestData *>(rdata);
+  bool firstCall = first_call;
+  bool wrap_around[2] = {false, false};
+  uint64_t path_hash = 0;
+  uint32_t last_lookup;
+  pRecord *prtmp = NULL, *pRec = NULL;
+  URL *url = request_info->hdr->url_get();
+  time_t now;
+
+  Debug("parent_select", "ParentConsistentHash::%s(): Using a consistent hash parent selection strategy.", __func__);
+  ink_assert(numParents(result) > 0 || result->rec->go_direct == true);
+  //
+  // Should only get into this state if we are supposed to go direct.
+  if (parents[PRIMARY] == NULL && parents[SECONDARY] == NULL) {
+    if (result->rec->go_direct == true) {
+      result->r = PARENT_DIRECT;
+    } else {
+      result->r = PARENT_FAIL;
+    }
+    result->hostname = NULL;
+    result->port = 0;
+    return;
+  }
+
+  // findParent() call if firstCall.
+  if (firstCall) {
+    last_lookup = PRIMARY;
+    path_hash = getPathHash(request_info, (ATSHash64 *)&hash);
+    fhash = chash[PRIMARY];
+    if (path_hash) {
+      prtmp = (pRecord *)fhash->lookup_by_hashval(path_hash, &result->chashIter[last_lookup], &wrap_around[last_lookup]);
+      if (prtmp)
+        pRec = (parents[last_lookup] + prtmp->idx);
+    }
+    // else called by nextParent().
+  } else {
+    if (chash[SECONDARY] != NULL) {
+      last_lookup = SECONDARY;
+      fhash = chash[SECONDARY];
+      path_hash = getPathHash(request_info, (ATSHash64 *)&hash);
+      prtmp = (pRecord *)fhash->lookup_by_hashval(path_hash, &result->chashIter[last_lookup], &wrap_around[last_lookup]);
+      if (prtmp)
+        pRec = (parents[last_lookup] + prtmp->idx);
+    } else {
+      last_lookup = PRIMARY;
+      fhash = chash[PRIMARY];
+      do { // search until we've selected a different parent.
+        prtmp = (pRecord *)fhash->lookup(NULL, &result->chashIter[last_lookup], &wrap_around[last_lookup], &hash);
+        if (prtmp)
+          pRec = (parents[last_lookup] + prtmp->idx);
+      } while (prtmp && strcmp(prtmp->hostname, result->hostname) == 0);
+    }
+  }
+
+  // didn't find a parent or the parent is marked unavailable.
+  if (!pRec || (pRec && !pRec->available)) {
+    // check to see if it is retryable.
+    if (pRec && !pRec->available) {
+      Debug("parent_select", "Parent.failedAt = %u, retry = %u, xact_start = %u", (unsigned int)pRec->failedAt,
+        (unsigned int)policy->ParentRetryTime, (unsigned int)request_info->xact_start);
+      if ((pRec->failedAt + policy->ParentRetryTime) < request_info->xact_start) {
+        // make sure that the proper state is recorded in the result structure
+        result->last_parent = pRec->idx;
+        result->last_lookup = last_lookup;
+        result->retry = true;
+        if (!result->rec->parent_is_proxy) {
+          result->r = PARENT_ORIGIN;
+        } else {
+          result->r = PARENT_SPECIFIED;
+        }
+        Debug("parent_select", "Down parent %s is now retryable, pRec: %p, result->retry: %d.", pRec->hostname, pRec, result->retry);
+      } else { // if not retryable find an available host on the primary ring.
+        last_lookup = PRIMARY;
+        fhash = chash[PRIMARY];
+        prtmp = (pRecord *)fhash->lookup_available(NULL, &result->chashIter[last_lookup], &wrap_around[last_lookup], &hash);
+        if (prtmp) {
+          pRec = (parents[last_lookup] + prtmp->idx);
+        } else if (chash[SECONDARY] != NULL) { // search the secondary if if available.
+          last_lookup = SECONDARY;
+          fhash = chash[SECONDARY];
+          prtmp = (pRecord *)fhash->lookup_available(NULL, &result->chashIter[last_lookup], &wrap_around[last_lookup], &hash);
+          if (prtmp) {
+            pRec = (parents[last_lookup] + prtmp->idx);
+          }
+        }
+      }
+    }
+  }
+
+  // use the available parent.
+  if (pRec && (pRec->available || result->retry)) {
+    if (!result->rec->parent_is_proxy) {
+      result->r = PARENT_ORIGIN;
+    } else {
+      result->r = PARENT_SPECIFIED;
+    }
+    result->hostname = pRec->hostname;
+    result->port = pRec->port;
+    result->last_parent = pRec->idx;
+    result->last_lookup = last_lookup;
+    ink_assert(result->hostname != NULL);
+    ink_assert(result->port != 0);
+    Debug("parent_select", "Chosen parent: %s.%d", result->hostname, result->port);
+  } else {
+    if (result->rec->go_direct == true && result->rec->parent_is_proxy) {
+      result->r = PARENT_DIRECT;
+    } else {
+      now = time(NULL);
+      // limit logging to no more than one message per second.
+      if (now > last_unavailable) {
+        int len = 0;
+        char *request_str = url->string_get_ref(&len);
+        if(request_str) {
+            Note("No available parents for request: %*s.", len, request_str);
+        }
+       ink_atomic_swap(&last_unavailable, now);
+      }
+      result->r = PARENT_FAIL;
+    }
+    result->hostname = NULL;
+    result->port = 0;
+    result->retry = false;
+  }
+
+  return;
+}
+
+void
+ParentConsistentHash::markParentDown(const ParentSelectionPolicy *policy, ParentResult *result)
+{
+  time_t now;
+  pRecord *pRec;
+  int new_fail_count = 0;
+
+  Debug("parent_select", "Starting ParentConsistentHash::markParentDown()");
+
+  //  Make sure that we are being called back with with a
+  //   result structure with a parent
+  ink_assert(result->r == PARENT_SPECIFIED || result->r == PARENT_ORIGIN);
+  if (result->r != PARENT_SPECIFIED && result->r != PARENT_ORIGIN) {
+    return;
+  }
+  // If we were set through the API we currently have not failover
+  //   so just return fail
+  if (result->rec == extApiRecord) {
+    return;
+  }
+
+  ink_assert((result->last_parent) < numParents(result));
+  pRec = parents[result->last_lookup] + result->last_parent;
+
+  // If the parent has already been marked down, just increment
+  //   the failure count.  If this is the first mark down on a
+  //   parent we need to both set the failure time and set
+  //   count to one.  It's possible for the count and time get out
+  //   sync due there being no locks.  Therefore the code should
+  //   handle this condition.  If this was the result of a retry, we
+  //   must update move the failedAt timestamp to now so that we continue
+  //   negative cache the parent
+  if (pRec->failedAt == 0 || result->retry == true) {
+    // Reread the current time.  We want this to be accurate since
+    //   it relates to how long the parent has been down.
+    now = time(NULL);
+
+    // Mark the parent as down
+    ink_atomic_swap(&pRec->failedAt, now);
+
+    // If this is clean mark down and not a failed retry, we
+    //   must set the count to reflect this
+    if (result->retry == false) {
+      new_fail_count = pRec->failCount = 1;
+    }
+
+    Note("Parent %s marked as down %s:%d", (result->retry) ? "retry" : "initially", pRec->hostname, pRec->port);
+
+  } else {
+    int old_count = ink_atomic_increment(&pRec->failCount, 1);
+
+    Debug("parent_select", "Parent fail count increased to %d for %s:%d", old_count + 1, pRec->hostname, pRec->port);
+    new_fail_count = old_count + 1;
+  }
+
+  if (new_fail_count > 0 && new_fail_count >= policy->FailThreshold) {
+    Note("Failure threshold met, http parent proxy %s:%d marked down", pRec->hostname, pRec->port);
+    ink_atomic_swap(&pRec->available, false);
+    Debug("parent_select", "Parent %s:%d marked unavailable, pRec->available=%d", pRec->hostname, pRec->port, pRec->available);
+  }
+}
+
+uint32_t
+ParentConsistentHash::numParents(ParentResult *result) const
+{
+  uint32_t n = 0;
+
+  switch (result->last_lookup) {
+  case PRIMARY:
+    n = result->rec->num_parents;
+    break;
+  case SECONDARY:
+    n = result->rec->num_secondary_parents;
+    break;
+  }
+
+  return n;
+}
+
+void
+ParentConsistentHash::markParentUp(ParentResult *result)
+{
+  pRecord *pRec;
+
+  //  Make sure that we are being called back with with a
+  //   result structure with a parent that is being retried
+  ink_release_assert(result->retry == true);
+  ink_assert(result->r == PARENT_SPECIFIED || result->r == PARENT_ORIGIN);
+  if (result->r != PARENT_SPECIFIED && result->r != PARENT_ORIGIN) {
+    return;
+  }
+  // If we were set through the API we currently have not failover
+  //   so just return fail
+  if (result->rec == extApiRecord) {
+    ink_assert(0);
+    return;
+  }
+
+  ink_assert((result->last_parent) < numParents(result));
+  pRec = parents[result->last_lookup] + result->last_parent;
+  ink_atomic_swap(&pRec->available, true);
+  Debug("parent_select", "%s:%s(): marked %s:%d available.", __FILE__, __func__, pRec->hostname, pRec->port);
+
+  ink_atomic_swap(&pRec->failedAt, (time_t)0);
+  int old_count = ink_atomic_swap(&pRec->failCount, 0);
+
+  if (old_count > 0) {
+    Note("http parent proxy %s:%d restored", pRec->hostname, pRec->port);
+  }
+}
diff --git a/proxy/ParentConsistentHash.h b/proxy/ParentConsistentHash.h
new file mode 100644
index 0000000..ca61fdb
--- /dev/null
+++ b/proxy/ParentConsistentHash.h
@@ -0,0 +1,62 @@
+/** @file
+
+  A brief file description
+
+  @section license License
+
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+ */
+
+/*****************************************************************************
+ *
+ *  ParentConsistentHash.h - Interface to Parent Consistent Hash.
+ *
+ ****************************************************************************/
+
+#ifndef _PARENT_CONSISTENT_HASH_H
+#define _PARENT_CONSISTENT_HASH_H
+
+#include "ParentSelection.h"
+
+//
+//  Implementation of round robin based upon consistent hash of the URL,
+//  ParentRR_t = P_CONSISTENT_HASH.
+//
+class ParentConsistentHash : public ParentSelectionStrategy
+{
+  // there are two hashes PRIMARY parents
+  // and SECONDARY parents.
+  ATSHash64Sip24 hash[2];
+  ATSConsistentHash *chash[2];
+  pRecord *parents[2];
+  bool foundParents[2][MAX_PARENTS];
+  bool ignore_query;
+  time_t last_unavailable;
+
+public:
+  static const int PRIMARY = 0;
+  static const int SECONDARY = 1;
+  ParentConsistentHash(ParentRecord *_parent_record);
+  ~ParentConsistentHash();
+  uint64_t getPathHash(HttpRequestData *hrdata, ATSHash64 *h);
+  void selectParent(const ParentSelectionPolicy *policy, bool firstCall, ParentResult *result, RequestData *rdata);
+  void markParentDown(const ParentSelectionPolicy *policy, ParentResult *result);
+  uint32_t numParents(ParentResult *result) const;
+  void markParentUp(ParentResult *result);
+};
+
+#endif
diff --git a/proxy/ParentRoundRobin.cc b/proxy/ParentRoundRobin.cc
new file mode 100644
index 0000000..c387e8c
--- /dev/null
+++ b/proxy/ParentRoundRobin.cc
@@ -0,0 +1,286 @@
+/** @file
+
+  Implementation of Parent Proxy routing
+
+  @section license License
+
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+ */
+#include "ParentRoundRobin.h"
+
+ParentRoundRobin::ParentRoundRobin(ParentRecord *parent_record, ParentRR_t _round_robin_type)
+{
+  round_robin_type = _round_robin_type;
+
+  if (is_debug_tag_set("parent_select")) {
+    switch (round_robin_type) {
+    case P_NO_ROUND_ROBIN:
+      Debug("parent_select", "Using a round robin parent selection strategy of type P_NO_ROUND_ROBIN.");
+      break;
+    case P_STRICT_ROUND_ROBIN:
+      Debug("parent_select", "Using a round robin parent selection strategy of type P_STRICT_ROUND_ROBIN.");
+      break;
+    case P_HASH_ROUND_ROBIN:
+      Debug("parent_select", "Using a round robin parent selection strategy of type P_HASH_ROUND_ROBIN.");
+      break;
+    default:
+      // should never see this, there is a problem if you do.
+      Debug("parent_select", "Using a round robin parent selection strategy of type UNKNOWN TYPE.");
+      break;
+    }
+  }
+}
+
+ParentRoundRobin::~ParentRoundRobin()
+{
+}
+
+void
+ParentRoundRobin::selectParent(const ParentSelectionPolicy *policy, bool first_call, ParentResult *result, RequestData *rdata)
+{
+  Debug("parent_select", "In ParentRoundRobin::selectParent(): Using a round robin parent selection strategy.");
+
+  int cur_index = 0;
+  bool parentUp = false;
+  bool parentRetry = false;
+  bool bypass_ok = (result->rec->go_direct == true && policy->DNS_ParentOnly == 0);
+  HttpRequestData *request_info = static_cast<HttpRequestData *>(rdata);
+  URL *url = request_info->hdr->url_get();
+
+  ink_assert(numParents(result) > 0 || result->rec->go_direct == true);
+
+  if (first_call) {
+    if (result->rec->parents == NULL) {
+      // We should only get into this state if
+      //   if we are supposed to go direct
+      ink_assert(result->rec->go_direct == true);
+      // Could not find a parent
+      if (result->rec->go_direct == true && result->rec->parent_is_proxy) {
+        result->r = PARENT_DIRECT;
+      } else {
+        result->r = PARENT_FAIL;
+      }
+
+      result->hostname = NULL;
+      result->port = 0;
+      return;
+    } else {
+      Debug("parent_select", "round_robin: %d", round_robin_type);
+      switch (round_robin_type) {
+      case P_HASH_ROUND_ROBIN:
+        // INKqa12817 - make sure to convert to host byte order
+        // Why was it important to do host order here?  And does this have any
+        // impact with the transition to IPv6?  The IPv4 functionality is
+        // preserved for now anyway as ats_ip_hash returns the 32-bit address in
+        // that case.
+        if (rdata->get_client_ip() != NULL) {
+          cur_index = result->start_parent = ntohl(ats_ip_hash(rdata->get_client_ip())) % result->rec->num_parents;
+        } else {
+          cur_index = 0;
+        }
+        break;
+      case P_STRICT_ROUND_ROBIN:
+        cur_index = ink_atomic_increment((int32_t *)&result->rec->rr_next, 1);
+        cur_index = result->start_parent = cur_index % result->rec->num_parents;
+        break;
+      case P_NO_ROUND_ROBIN:
+        cur_index = result->start_parent = 0;
+        break;
+      default:
+        ink_release_assert(0);
+      }
+    }
+  } else {
+    // Move to next parent due to failure
+    cur_index = (result->last_parent + 1) % result->rec->num_parents;
+
+    // Check to see if we have wrapped around
+    if ((unsigned int)cur_index == result->start_parent) {
+      // We've wrapped around so bypass if we can
+      if (bypass_ok == true) {
+        // Could not find a parent
+        if (result->rec->go_direct == true && result->rec->parent_is_proxy) {
+          result->r = PARENT_DIRECT;
+        } else {
+          result->r = PARENT_FAIL;
+        }
+        result->hostname = NULL;
+        result->port = 0;
+        return;
+      } else {
+        // Bypass disabled so keep trying, ignoring whether we think
+        //   a parent is down or not
+        result->wrap_around = true;
+      }
+    }
+  }
+  // Loop through the array of parent seeing if any are up or
+  //   should be retried
+  do {
+    // DNS ParentOnly inhibits bypassing the parent so always return that t
+    if ((result->rec->parents[cur_index].failedAt == 0) || (result->rec->parents[cur_index].failCount < policy->FailThreshold)) {
+      Debug("parent_select", "FailThreshold = %d", policy->FailThreshold);
+      Debug("parent_select", "Selecting a parent due to little failCount"
+                             "(faileAt: %u failCount: %d)",
+            (unsigned)result->rec->parents[cur_index].failedAt, result->rec->parents[cur_index].failCount);
+      parentUp = true;
+    } else {
+      if ((result->wrap_around) ||
+          ((result->rec->parents[cur_index].failedAt + policy->ParentRetryTime) < request_info->xact_start)) {
+        Debug("parent_select", "Parent[%d].failedAt = %u, retry = %u,xact_start = %" PRId64 " but wrap = %d", cur_index,
+              (unsigned)result->rec->parents[cur_index].failedAt, policy->ParentRetryTime, (int64_t)request_info->xact_start,
+              result->wrap_around);
+        // Reuse the parent
+        parentUp = true;
+        parentRetry = true;
+        Debug("parent_select", "Parent marked for retry %s:%d", result->rec->parents[cur_index].hostname,
+              result->rec->parents[cur_index].port);
+      } else {
+        parentUp = false;
+      }
+    }
+
+    if (parentUp == true) {
+      if (!result->rec->parent_is_proxy) {
+        result->r = PARENT_ORIGIN;
+      } else {
+        result->r = PARENT_SPECIFIED;
+      }
+      result->hostname = result->rec->parents[cur_index].hostname;
+      result->port = result->rec->parents[cur_index].port;
+      result->last_parent = cur_index;
+      result->retry = parentRetry;
+      ink_assert(result->hostname != NULL);
+      ink_assert(result->port != 0);
+      Debug("parent_select", "Chosen parent = %s.%d", result->hostname, result->port);
+      return;
+    }
+    cur_index = (cur_index + 1) % result->rec->num_parents;
+  } while ((unsigned int)cur_index != result->start_parent);
+
+  if (result->rec->go_direct == true && result->rec->parent_is_proxy) {
+    result->r = PARENT_DIRECT;
+  } else {
+    int len = 0;
+    char *request_str = url->string_get_ref(&len);
+    if (request_str) {
+      Note("No available parents for request: %*s.", len, request_str);
+    }
+    result->r = PARENT_FAIL;
+  }
+
+  result->hostname = NULL;
+  result->port = 0;
+}
+
+uint32_t
+ParentRoundRobin::numParents(ParentResult *result) const
+{
+  return result->rec->num_parents;
+}
+
+void
+ParentRoundRobin::markParentDown(const ParentSelectionPolicy *policy, ParentResult *result)
+{
+  time_t now;
+  pRecord *pRec;
+  int new_fail_count = 0;
+
+  Debug("parent_select", "Starting ParentRoundRobin::markParentDown()");
+  //  Make sure that we are being called back with with a
+  //   result structure with a parent
+  ink_assert(result->r == PARENT_SPECIFIED || result->r == PARENT_ORIGIN);
+  if (result->r != PARENT_SPECIFIED && result->r != PARENT_ORIGIN) {
+    return;
+  }
+  // If we were set through the API we currently have not failover
+  //   so just return fail
+  if (result->rec == extApiRecord) {
+    return;
+  }
+
+  ink_assert((int)(result->last_parent) < result->rec->num_parents);
+  pRec = result->rec->parents + result->last_parent;
+
+  // If the parent has already been marked down, just increment
+  //   the failure count.  If this is the first mark down on a
+  //   parent we need to both set the failure time and set
+  //   count to one.  It's possible for the count and time get out
+  //   sync due there being no locks.  Therefore the code should
+  //   handle this condition.  If this was the result of a retry, we
+  //   must update move the failedAt timestamp to now so that we continue
+  //   negative cache the parent
+  if (pRec->failedAt == 0 || result->retry == true) {
+    // Reread the current time.  We want this to be accurate since
+    //   it relates to how long the parent has been down.
+    now = time(NULL);
+
+    // Mark the parent as down
+    ink_atomic_swap(&pRec->failedAt, now);
+
+    // If this is clean mark down and not a failed retry, we
+    //   must set the count to reflect this
+    if (result->retry == false) {
+      new_fail_count = pRec->failCount = 1;
+    }
+
+    Note("Parent %s marked as down %s:%d", (result->retry) ? "retry" : "initially", pRec->hostname, pRec->port);
+
+  } else {
+    int old_count = ink_atomic_increment(&pRec->failCount, 1);
+
+    Debug("parent_select", "Parent fail count increased to %d for %s:%d", old_count + 1, pRec->hostname, pRec->port);
+    new_fail_count = old_count + 1;
+  }
+
+  if (new_fail_count > 0 && new_fail_count >= policy->FailThreshold) {
+    Note("Failure threshold met, http parent proxy %s:%d marked down", pRec->hostname, pRec->port);
+    ink_atomic_swap(&pRec->available, false);
+    Debug("parent_select", "Parent marked unavailable, pRec->available=%d", pRec->available);
+  }
+}
+
+void
+ParentRoundRobin::markParentUp(ParentResult *result)
+{
+  pRecord *pRec;
+
+  //  Make sure that we are being called back with with a
+  //   result structure with a parent that is being retried
+  ink_release_assert(result->retry == true);
+  ink_assert(result->r == PARENT_SPECIFIED || result->r == PARENT_ORIGIN);
+  if (result->r != PARENT_SPECIFIED && result->r != PARENT_ORIGIN) {
+    return;
+  }
+  // If we were set through the API we currently have not failover
+  //   so just return fail
+  if (result->rec == extApiRecord) {
+    ink_assert(0);
+    return;
+  }
+
+  ink_assert((int)(result->last_parent) < result->rec->num_parents);
+  pRec = result->rec->parents + result->last_parent;
+  ink_atomic_swap(&pRec->available, true);
+
+  ink_atomic_swap(&pRec->failedAt, (time_t)0);
+  int old_count = ink_atomic_swap(&pRec->failCount, 0);
+
+  if (old_count > 0) {
+    Note("http parent proxy %s:%d restored", pRec->hostname, pRec->port);
+  }
+}
diff --git a/proxy/ParentRoundRobin.h b/proxy/ParentRoundRobin.h
new file mode 100644
index 0000000..57b6832
--- /dev/null
+++ b/proxy/ParentRoundRobin.h
@@ -0,0 +1,48 @@
+/** @file
+
+  A brief file description
+
+  @section license License
+
+  Licensed to the Apache Software Foundation (ASF) under one
+  or more contributor license agreements.  See the NOTICE file
+  distributed with this work for additional information
+  regarding copyright ownership.  The ASF licenses this file
+  to you under the Apache License, Version 2.0 (the
+  "License"); you may not use this file except in compliance
+  with the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+ */
+
+/*****************************************************************************
+ *
+ *  ParentRoundRobin.h - Implementation of various round robin strategies.
+ *
+ *****************************************************************************/
+
+#ifndef _PARENT_ROUND_ROBIN_H
+#define _PARENT_ROUND_ROBIN_H
+
+#include "ParentSelection.h"
+
+class ParentRoundRobin : public ParentSelectionStrategy
+{
+  ParentRR_t round_robin_type;
+
+public:
+  ParentRoundRobin(ParentRecord *_parent_record, ParentRR_t _round_robin_type);
+  ~ParentRoundRobin();
+  void selectParent(const ParentSelectionPolicy *policy, bool firstCall, ParentResult *result, RequestData *rdata);
+  void markParentDown(const ParentSelectionPolicy *policy, ParentResult *result);
+  uint32_t numParents(ParentResult *result) const;
+  void markParentUp(ParentResult *result);
+};
+
+#endif
diff --git a/proxy/ParentSelection.cc b/proxy/ParentSelection.cc
index 9342690..81431a8 100644
--- a/proxy/ParentSelection.cc
+++ b/proxy/ParentSelection.cc
@@ -23,6 +23,8 @@
 #include "libts.h"
 #include "P_EventSystem.h"
 #include "ParentSelection.h"
+#include "ParentConsistentHash.h"
+#include "ParentRoundRobin.h"
 #include "ControlMatcher.h"
 #include "Main.h"
 #include "Error.h"
@@ -48,9 +50,8 @@ static const char *enable_var = "proxy.config.http.parent_proxy_routing_enable";
 static const char *threshold_var = "proxy.config.http.parent_proxy.fail_threshold";
 static const char *dns_parent_only_var = "proxy.config.http.no_dns_just_forward_to_parent";
 
-static const char *ParentResultStr[] = {"Parent_Undefined", "Parent_Direct", "Parent_Specified", "Parent_Failed"};
-
-static const char *ParentRRStr[] = {"false", "strict", "true", "consistent"};
+static const char *ParentResultStr[] = {"PARENT_UNDEFINED", "PARENT_DIRECT", "PARENT_SPECIFIED",
+                                        "PARENT_AGENT",     "PARENT_FAIL",   "PARENT_ORIGIN"};
 
 //
 //  Config Callback Prototypes
@@ -64,122 +65,38 @@ enum ParentCB_t {
   PARENT_DNS_ONLY_CB,
 };
 
-// If the parent was set by the external customer api,
-//   our HttpRequestData structure told us what parent to
-//   use and we are only called to preserve clean interface
-//   between HttpTransact & the parent selection code.  The following
-ParentRecord *const extApiRecord = (ParentRecord *)0xeeeeffff;
-
-ParentConfigParams::ParentConfigParams()
-  : ParentTable(NULL), DefaultParent(NULL), ParentRetryTime(30), ParentEnable(0), FailThreshold(10), DNS_ParentOnly(0)
-{
-}
-
-ParentConfigParams::~ParentConfigParams()
-{
-  if (ParentTable) {
-    delete ParentTable;
-  }
-
-  if (DefaultParent) {
-    delete DefaultParent;
-  }
-}
-
-int ParentConfig::m_id = 0;
-
-//
-//   Begin API functions
-//
-void
-ParentConfig::startup()
+ParentSelectionPolicy::ParentSelectionPolicy()
 {
-  parentConfigUpdate = new ConfigUpdateHandler<ParentConfig>();
-
-  // Load the initial configuration
-  reconfigure();
-
-  // Setup the callbacks for reconfiuration
-  //   parent table
-  parentConfigUpdate->attach(file_var);
-  //   default parent
-  parentConfigUpdate->attach(default_var);
-  //   Retry time
-  parentConfigUpdate->attach(retry_var);
-  //   Enable
-  parentConfigUpdate->attach(enable_var);
-
-  //   Fail Threshold
-  parentConfigUpdate->attach(threshold_var);
-
-  //   DNS Parent Only
-  parentConfigUpdate->attach(dns_parent_only_var);
-}
-
-void
-ParentConfig::reconfigure()
-{
-  char *default_val = NULL;
-  int retry_time = 30;
-  int enable = 0;
-  int fail_threshold;
-  int dns_parent_only;
-
-  ParentConfigParams *params;
-  params = new ParentConfigParams;
-
-  // Allocate parent table
-  params->ParentTable = new P_table(file_var, modulePrefix, &http_dest_tags);
-
-  // Handle default parent
-  PARENT_ReadConfigStringAlloc(default_val, default_var);
-  params->DefaultParent = createDefaultParent(default_val);
-  ats_free(default_val);
+  bool enable = false;
+  int32_t retry_time = 0;
+  int32_t fail_threshold = 0;
+  int32_t dns_parent_only = 0;
 
   // Handle parent timeout
   PARENT_ReadConfigInteger(retry_time, retry_var);
-  params->ParentRetryTime = retry_time;
+  ParentRetryTime = retry_time;
 
   // Handle parent enable
   PARENT_ReadConfigInteger(enable, enable_var);
-  params->ParentEnable = enable;
+  ParentEnable = enable;
 
   // Handle the fail threshold
   PARENT_ReadConfigInteger(fail_threshold, threshold_var);
-  params->FailThreshold = fail_threshold;
+  FailThreshold = fail_threshold;
 
   // Handle dns parent only
   PARENT_ReadConfigInteger(dns_parent_only, dns_parent_only_var);
-  params->DNS_ParentOnly = dns_parent_only;
-
-  m_id = configProcessor.set(m_id, params);
-
-  if (is_debug_tag_set("parent_config")) {
-    ParentConfig::print();
-  }
+  DNS_ParentOnly = dns_parent_only;
 }
 
-// void ParentConfig::print
-//
-//   Debugging function
-//
-void
-ParentConfig::print()
+ParentConfigParams::ParentConfigParams(P_table *_parent_table) : parent_table(_parent_table), DefaultParent(NULL), policy()
 {
-  ParentConfigParams *params = ParentConfig::acquire();
-
-  printf("Parent Selection Config\n");
-  printf("\tEnabled %d\tRetryTime %d\tParent DNS Only %d\n", params->ParentEnable, params->ParentRetryTime, params->DNS_ParentOnly);
-  if (params->DefaultParent == NULL) {
-    printf("\tNo Default Parent\n");
-  } else {
-    printf("\tDefault Parent:\n");
-    params->DefaultParent->Print();
-  }
-  printf("  ");
-  params->ParentTable->Print();
+  char *default_val = NULL;
 
-  ParentConfig::release(params);
+  // Handle default parent
+  PARENT_ReadConfigStringAlloc(default_val, default_var);
+  DefaultParent = createDefaultParent(default_val);
+  ats_free(default_val);
 }
 
 bool
@@ -188,31 +105,19 @@ ParentConfigParams::apiParentExists(HttpRequestData *rdata)
   return (rdata->api_info && rdata->api_info->parent_proxy_name != NULL && rdata->api_info->parent_proxy_port > 0);
 }
 
-bool
-ParentConfigParams::parentExists(HttpRequestData *rdata)
-{
-  ParentResult junk;
-
-  findParent(rdata, &junk);
-
-  if (junk.r == PARENT_SPECIFIED || junk.r == PARENT_ORIGIN) {
-    return true;
-  } else {
-    return false;
-  }
-}
-
 void
 ParentConfigParams::findParent(HttpRequestData *rdata, ParentResult *result)
 {
-  P_table *tablePtr = ParentTable;
+  P_table *tablePtr = parent_table;
   ParentRecord *defaultPtr = DefaultParent;
   ParentRecord *rec;
 
+  Debug("parent_select", "In ParentConfigParams::findParent(): parent_table: %p.", parent_table);
   ink_assert(result->r == PARENT_UNDEFINED);
 
   // Check to see if we are enabled
-  if (ParentEnable == 0) {
+  Debug("parent_select", "policy.ParentEnable: %d", policy.ParentEnable);
+  if (policy.ParentEnable == 0) {
     result->r = PARENT_DIRECT;
     return;
   }
@@ -221,9 +126,6 @@ ParentConfigParams::findParent(HttpRequestData *rdata, ParentResult *result)
   result->epoch = tablePtr;
   result->line_number = 0xffffffff;
   result->wrap_around = false;
-  // if this variabel is not set, we have problems: the code in
-  // FindParent relies on the value of start_parent and when it is not
-  // initialized, the code in FindParent can get into an infinite loop!
   result->start_parent = 0;
   result->last_parent = 0;
 
@@ -252,160 +154,52 @@ ParentConfigParams::findParent(HttpRequestData *rdata, ParentResult *result)
       rec = result->rec = defaultPtr;
     } else {
       result->r = PARENT_DIRECT;
-      Debug("cdn", "Returning PARENT_DIRECT (no parents were found)");
+      Debug("parent_select", "Returning PARENT_DIRECT (no parents were found)");
       return;
     }
   }
-  // Loop through the set of parents to see if any are
-  //   available
-  Debug("cdn", "Calling FindParent from findParent");
-
-  // Bug INKqa08251:
-  // If a parent proxy is set by the API,
-  // no need to call FindParent()
-  if (rec != extApiRecord)
-    rec->FindParent(true, result, rdata, this);
-
-  if (is_debug_tag_set("parent_select") || is_debug_tag_set("cdn")) {
-    switch (result->r) {
-    case PARENT_UNDEFINED:
-      Debug("cdn", "PARENT_UNDEFINED");
-      break;
-    case PARENT_FAIL:
-      Debug("cdn", "PARENT_FAIL");
-      break;
-    case PARENT_DIRECT:
-      Debug("cdn", "PARENT_DIRECT");
-      break;
-    case PARENT_SPECIFIED:
-      Debug("cdn", "PARENT_SPECIFIED");
-      break;
-    case PARENT_ORIGIN:
-      Debug("cdn", "PARENT_ORIGIN");
-      break;
-    default:
-      // Handled here:
-      // PARENT_AGENT
-      break;
-    }
 
-    const char *host = rdata->get_host();
-
-    switch (result->r) {
-    case PARENT_UNDEFINED:
-    case PARENT_FAIL:
-    case PARENT_DIRECT:
-      Debug("parent_select", "Result for %s was %s", host, ParentResultStr[result->r]);
-      break;
-    case PARENT_ORIGIN:
-    case PARENT_SPECIFIED:
-      Debug("parent_select", "Result for %s was parent %s:%d", host, result->hostname, result->port);
-      break;
-    default:
-      // Handled here:
-      // PARENT_AGENT
-      break;
-    }
+  if (rec != extApiRecord) {
+    // first lookup
+    selectParent(true, result, rdata);
   }
-}
-
 
-void
-ParentConfigParams::recordRetrySuccess(ParentResult *result)
-{
-  pRecord *pRec;
+  const char *host = rdata->get_host();
 
-  //  Make sure that we are being called back with with a
-  //   result structure with a parent that is being retried
-  ink_release_assert(result->retry == true);
-  ink_assert(result->r == PARENT_SPECIFIED || result->r == PARENT_ORIGIN);
-  if (result->r != PARENT_SPECIFIED && result->r != PARENT_ORIGIN) {
-    return;
-  }
-  // If we were set through the API we currently have not failover
-  //   so just return fail
-  if (result->rec == extApiRecord) {
-    ink_assert(0);
-    return;
-  }
-
-  ink_assert((int)(result->last_parent) < result->rec->num_parents);
-  pRec = result->rec->parents + result->last_parent;
-
-  pRec->available = true;
-
-  ink_atomic_swap(&pRec->failedAt, (time_t)0);
-  int old_count = ink_atomic_swap(&pRec->failCount, 0);
-
-  if (old_count > 0) {
-    Note("http parent proxy %s:%d restored", pRec->hostname, pRec->port);
-  }
-}
-
-void
-ParentConfigParams::markParentDown(ParentResult *result)
-{
-  time_t now;
-  pRecord *pRec;
-  int new_fail_count = 0;
-
-  //  Make sure that we are being called back with with a
-  //   result structure with a parent
-  ink_assert(result->r == PARENT_SPECIFIED || result->r == PARENT_ORIGIN);
-  if (result->r != PARENT_SPECIFIED && result->r != PARENT_ORIGIN) {
-    return;
-  }
-  // If we were set through the API we currently have not failover
-  //   so just return fail
-  if (result->rec == extApiRecord) {
-    return;
-  }
-
-  ink_assert((int)(result->last_parent) < result->rec->num_parents);
-  pRec = result->rec->parents + result->last_parent;
-
-  // If the parent has already been marked down, just increment
-  //   the failure count.  If this is the first mark down on a
-  //   parent we need to both set the failure time and set
-  //   count to one.  It's possible for the count and time get out
-  //   sync due there being no locks.  Therefore the code should
-  //   handle this condition.  If this was the result of a retry, we
-  //   must update move the failedAt timestamp to now so that we continue
-  //   negative cache the parent
-  if (pRec->failedAt == 0 || result->retry == true) {
-    // Reread the current time.  We want this to be accurate since
-    //   it relates to how long the parent has been down.
-    now = time(NULL);
-
-    // Mark the parent as down
-    ink_atomic_swap(&pRec->failedAt, now);
-
-    // If this is clean mark down and not a failed retry, we
-    //   must set the count to reflect this
-    if (result->retry == false) {
-      new_fail_count = pRec->failCount = 1;
-    }
-
-    Note("Parent %s marked as down %s:%d", (result->retry) ? "retry" : "initially", pRec->hostname, pRec->port);
-
-  } else {
-    int old_count = ink_atomic_increment(&pRec->failCount, 1);
-
-    Debug("parent_select", "Parent fail count increased to %d for %s:%d", old_count + 1, pRec->hostname, pRec->port);
-    new_fail_count = old_count + 1;
-  }
-
-  if (new_fail_count > 0 && new_fail_count == FailThreshold) {
-    Note("Failure threshold met, http parent proxy %s:%d marked down", pRec->hostname, pRec->port);
-    pRec->available = false;
-    Debug("parent_select", "Parent marked unavailable, pRec->available=%d", pRec->available);
+  switch (result->r) {
+  case PARENT_UNDEFINED:
+    Debug("parent_select", "PARENT_UNDEFINED");
+    Debug("parent_select", "Result for %s was %s", host, ParentResultStr[result->r]);
+    break;
+  case PARENT_FAIL:
+    Debug("parent_select", "PARENT_FAIL");
+    break;
+  case PARENT_DIRECT:
+    Debug("parent_select", "PARENT_DIRECT");
+    Debug("parent_select", "Result for %s was %s", host, ParentResultStr[result->r]);
+    break;
+  case PARENT_ORIGIN:
+    Debug("parent_select", "PARENT_ORIGIN");
+    Debug("parent_select", "Result for %s was parent %s:%d", host, result->hostname, result->port);
+    break;
+  case PARENT_SPECIFIED:
+    Debug("parent_select", "PARENT_SPECIFIED");
+    Debug("parent_select", "Result for %s was parent %s:%d", host, result->hostname, result->port);
+    break;
+  default:
+    // Handled here:
+    // PARENT_AGENT
+    break;
   }
 }
 
 void
 ParentConfigParams::nextParent(HttpRequestData *rdata, ParentResult *result)
 {
-  P_table *tablePtr = ParentTable;
+  P_table *tablePtr = parent_table;
+
+  Debug("parent_select", "ParentConfigParams::nextParent(): parent_table: %p, result->rec: %p, result->epoch: %p", parent_table,
+        result->rec, result->epoch);
 
   //  Make sure that we are being called back with a
   //   result structure with a parent
@@ -421,300 +215,154 @@ ParentConfigParams::nextParent(HttpRequestData *rdata, ParentResult *result)
     result->r = PARENT_FAIL;
     return;
   }
-  // The epoch pointer is a legacy from the time when the tables
-  //  would be swapped and deleted in the future.  I'm using the
-  //  pointer now to ensure that the ParentConfigParams structure
-  //  is properly used.  The table should never change out from
-  //  under the a http transaction
+  Debug("parent_select", "ParentConfigParams::nextParent(): result->r: %d, tablePtr: %p, result->epoch: %p", result->r, tablePtr,
+        result->epoch);
   ink_release_assert(tablePtr == result->epoch);
 
   // Find the next parent in the array
-  Debug("cdn", "Calling FindParent from nextParent");
-  result->rec->FindParent(false, result, rdata, this);
+  Debug("parent_select", "Calling selectParent() from nextParent");
+  selectParent(false, result, rdata);
+
+  const char *host = rdata->get_host();
 
   switch (result->r) {
   case PARENT_UNDEFINED:
-    Debug("cdn", "PARENT_UNDEFINED");
+    Debug("parent_select", "PARENT_UNDEFINED");
+    Debug("parent_select", "Retry result for %s was %s", host, ParentResultStr[result->r]);
     break;
   case PARENT_FAIL:
-    Debug("cdn", "PARENT_FAIL");
+    Debug("parent_select", "PARENT_FAIL");
+    Debug("parent_select", "Retry result for %s was %s", host, ParentResultStr[result->r]);
     break;
   case PARENT_DIRECT:
-    Debug("cdn", "PARENT_DIRECT");
+    Debug("parent_select", "PARENT_DIRECT");
+    Debug("parent_select", "Retry result for %s was %s", host, ParentResultStr[result->r]);
     break;
   case PARENT_ORIGIN:
-    Debug("cdn", "PARENT_ORIGIN");
+    Debug("parent_select", "PARENT_ORIGIN");
+    Debug("parent_select", "Retry result for %s was parent %s:%d", host, result->hostname, result->port);
     break;
   case PARENT_SPECIFIED:
-    Debug("cdn", "PARENT_SPECIFIED");
+    Debug("parent_select", "Retry result for %s was parent %s:%d", host, result->hostname, result->port);
     break;
   default:
     // Handled here:
     // PARENT_AGENT
     break;
   }
-
-  if (is_debug_tag_set("parent_select")) {
-    const char *host = rdata->get_host();
-
-    switch (result->r) {
-    case PARENT_UNDEFINED:
-    case PARENT_FAIL:
-    case PARENT_DIRECT:
-      Debug("parent_select", "Retry result for %s was %s", host, ParentResultStr[result->r]);
-      break;
-    case PARENT_ORIGIN:
-    case PARENT_SPECIFIED:
-      Debug("parent_select", "Retry result for %s was parent %s:%d", host, result->hostname, result->port);
-      break;
-    default:
-      // Handled here:
-      // PARENT_AGENT
-      break;
-    }
-  }
 }
 
-//
-//   End API functions
-//
-
-uint64_t
-ParentRecord::getPathHash(HttpRequestData *hrdata, ATSHash64 *h)
+bool
+ParentConfigParams::parentExists(HttpRequestData *rdata)
 {
-  const char *tmp = NULL;
-  int len;
-  URL *url = hrdata->hdr->url_get();
+  ParentResult result;
 
-  // Always hash on '/' because paths returned by ATS are always stripped of it
-  h->update("/", 1);
-
-  tmp = url->path_get(&len);
-  if (tmp) {
-    h->update(tmp, len);
-  }
+  findParent(rdata, &result);
 
-  if (!ignore_query) {
-    tmp = url->query_get(&len);
-    if (tmp) {
-      h->update("?", 1);
-      h->update(tmp, len);
-    }
+  if (result.r == PARENT_SPECIFIED || result.r == PARENT_ORIGIN) {
+    return true;
+  } else {
+    return false;
   }
-
-  h->final();
-
-  return h->get();
 }
 
+int ParentConfig::m_id = 0;
+
 void
-ParentRecord::FindParent(bool first_call, ParentResult *result, RequestData *rdata, ParentConfigParams *config)
+ParentConfig::startup()
 {
-  Debug("cdn", "Entering FindParent (the inner loop)");
-  int cur_index = 0;
-  bool parentUp = false;
-  bool parentRetry = false;
-  bool bypass_ok = (go_direct == true && config->DNS_ParentOnly == 0);
-  uint64_t path_hash;
-
-  ATSHash64Sip24 hash;
-  pRecord *prtmp = NULL;
-
-  HttpRequestData *request_info = static_cast<HttpRequestData *>(rdata);
-
-  ink_assert(num_parents > 0 || go_direct == true);
-
-  if (first_call) {
-    if (parents == NULL) {
-      // We should only get into this state if
-      //   if we are supposed to go direct
-      ink_assert(go_direct == true);
-      goto NO_PARENTS;
-    } else {
-      switch (round_robin) {
-      case P_HASH_ROUND_ROBIN:
-        // INKqa12817 - make sure to convert to host byte order
-        // Why was it important to do host order here?  And does this have any
-        // impact with the transition to IPv6?  The IPv4 functionality is
-        // preserved for now anyway as ats_ip_hash returns the 32-bit address in
-        // that case.
-        if (rdata->get_client_ip() != NULL) {
-          cur_index = ntohl(ats_ip_hash(rdata->get_client_ip())) % num_parents;
-        } else {
-          cur_index = 0;
-        }
-        break;
-      case P_CONSISTENT_HASH:
-        path_hash = getPathHash(request_info, (ATSHash64 *)&hash);
-        if (path_hash) {
-          prtmp = (pRecord *)chash->lookup_by_hashval(path_hash, &result->chashIter, &result->wrap_around);
-          if (prtmp) {
-            cur_index = prtmp->idx;
-            result->foundParents[cur_index] = true;
-            result->start_parent++;
-            break;
-          } else {
-            Error("Consistent Hash lookup returned NULL (first lookup)");
-          }
-        } else {
-          Error("Could not find path");
-        }
-      // Fall through to round robin
-      case P_STRICT_ROUND_ROBIN:
-        cur_index = ink_atomic_increment((int32_t *)&rr_next, 1);
-        cur_index = cur_index % num_parents;
-        break;
-      case P_NO_ROUND_ROBIN:
-        cur_index = result->start_parent = 0;
-        break;
-      default:
-        ink_release_assert(0);
-      }
-    }
-  } else {
-    if (round_robin == P_CONSISTENT_HASH) {
-      Debug("parent_select", "result->start_parent=%d, num_parents=%d", result->start_parent, num_parents);
-      if (result->start_parent == (unsigned int)num_parents) {
-        result->wrap_around = true;
-        result->start_parent = 0;
-        memset(result->foundParents, 0, sizeof(result->foundParents));
-      }
+  parentConfigUpdate = new ConfigUpdateHandler<ParentConfig>();
 
-      do {
-        prtmp = (pRecord *)chash->lookup(NULL, 0, &result->chashIter, &result->wrap_around, &hash);
-      } while (prtmp && result->foundParents[prtmp->idx]);
+  // Load the initial configuration
+  reconfigure();
 
-      if (prtmp) {
-        cur_index = prtmp->idx;
-        result->foundParents[cur_index] = true;
-        result->start_parent++;
-      } else {
-        Error("Consistent Hash lookup returned NULL (subsequent lookup)");
-        cur_index = ink_atomic_increment((int32_t *)&rr_next, 1);
-        cur_index = cur_index % num_parents;
-      }
-    } else {
-      // Move to next parent due to failure
-      cur_index = (result->last_parent + 1) % num_parents;
-
-      // Check to see if we have wrapped around
-      if ((unsigned int)cur_index == result->start_parent) {
-        // We've wrapped around so bypass if we can
-        if (bypass_ok == true) {
-          goto NO_PARENTS;
-        } else {
-        // Bypass disabled so keep trying, ignoring whether we think
-        //   a parent is down or not
-        FORCE_WRAP_AROUND:
-          result->wrap_around = true;
-        }
-      }
-    }
-  }
+  // Setup the callbacks for reconfiuration
+  //   parent table
+  parentConfigUpdate->attach(file_var);
+  //   default parent
+  parentConfigUpdate->attach(default_var);
+  //   Retry time
+  parentConfigUpdate->attach(retry_var);
+  //   Enable
+  parentConfigUpdate->attach(enable_var);
 
-  // Loop through the array of parent seeing if any are up or
-  //   should be retried
-  do {
-    // DNS ParentOnly inhibits bypassing the parent so always return that t
-    if ((parents[cur_index].failedAt == 0) || (parents[cur_index].failCount < config->FailThreshold)) {
-      Debug("parent_select", "config->FailThreshold = %d", config->FailThreshold);
-      Debug("parent_select", "Selecting a parent due to little failCount"
-                             "(failedAt: %u failCount: %d)",
-            (unsigned)parents[cur_index].failedAt, parents[cur_index].failCount);
-      parentUp = true;
-    } else {
-      if ((result->wrap_around) || ((parents[cur_index].failedAt + config->ParentRetryTime) < request_info->xact_start)) {
-        Debug("parent_select", "Parent[%d].failedAt = %u, retry = %u,xact_start = %" PRId64 " but wrap = %d", cur_index,
-              (unsigned)parents[cur_index].failedAt, config->ParentRetryTime, (int64_t)request_info->xact_start,
-              result->wrap_around);
-        // Reuse the parent
-        parentUp = true;
-        parentRetry = true;
-        Debug("parent_select", "Parent marked for retry %s:%d", parents[cur_index].hostname, parents[cur_index].port);
-      } else {
-        parentUp = false;
-      }
-    }
+  //   Fail Threshold
+  parentConfigUpdate->attach(threshold_var);
 
-    if (parentUp == true) {
-      if (!this->parent_is_proxy) {
-        result->r = PARENT_ORIGIN;
-      } else {
-        result->r = PARENT_SPECIFIED;
-      }
-      result->hostname = parents[cur_index].hostname;
-      result->port = parents[cur_index].port;
-      result->last_parent = cur_index;
-      result->retry = parentRetry;
-      ink_assert(result->hostname != NULL);
-      ink_assert(result->port != 0);
-      Debug("parent_select", "Chosen parent = %s.%d", result->hostname, result->port);
-      return;
-    }
+  //   DNS Parent Only
+  parentConfigUpdate->attach(dns_parent_only_var);
+}
 
-    if (round_robin == P_CONSISTENT_HASH) {
-      if (result->start_parent == (unsigned int)num_parents) {
-        result->wrap_around = false;
-        result->start_parent = 0;
-        memset(result->foundParents, 0, sizeof(result->foundParents));
-      }
+void
+ParentConfig::reconfigure()
+{
+  ParentConfigParams *params = NULL;
 
-      do {
-        prtmp = (pRecord *)chash->lookup(NULL, 0, &(result->chashIter), &result->wrap_around, (ATSHash64 *)&hash);
-      } while (prtmp && result->foundParents[prtmp->idx]);
+  // Allocate parent table
+  P_table *pTable = new P_table(file_var, modulePrefix, &http_dest_tags);
 
-      if (prtmp) {
-        cur_index = prtmp->idx;
-        result->foundParents[cur_index] = true;
-        result->start_parent++;
-      }
-    } else {
-      cur_index = (cur_index + 1) % num_parents;
-    }
+  params = new ParentConfigParams(pTable);
+  ink_assert(params != NULL);
 
-  } while ((round_robin == P_CONSISTENT_HASH ? result->wrap_around : ((unsigned int)cur_index != result->start_parent)));
+  m_id = configProcessor.set(m_id, params);
 
-  // We can't bypass so retry, taking any parent that we can
-  if (bypass_ok == false) {
-    goto FORCE_WRAP_AROUND;
+  if (is_debug_tag_set("parent_config")) {
+    ParentConfig::print();
   }
+}
 
-NO_PARENTS:
+// void ParentConfig::print
+//
+//   Debugging function
+//
+void
+ParentConfig::print()
+{
+  ParentConfigParams *params = ParentConfig::acquire();
 
-  // Could not find a parent
-  if (this->go_direct == true) {
-    result->r = PARENT_DIRECT;
+  printf("Parent Selection Config\n");
+  printf("\tEnabled %d\tRetryTime %d\tParent DNS Only %d\n", params->policy.ParentEnable, params->policy.ParentRetryTime,
+         params->policy.DNS_ParentOnly);
+  if (params->DefaultParent == NULL) {
+    printf("\tNo Default Parent\n");
   } else {
-    result->r = PARENT_FAIL;
+    printf("\tDefault Parent:\n");
+    params->DefaultParent->Print();
   }
+  printf("  ");
+  params->parent_table->Print();
 
-  result->hostname = NULL;
-  result->port = 0;
+  ParentConfig::release(params);
 }
 
-// const char* ParentRecord::ProcessParents(char* val)
+// const char* ParentRecord::ProcessParents(char* val, bool isPrimary)
 //
 //   Reads in the value of a "round-robin" or "order"
 //     directive and parses out the individual parents
-//     allocates and builds the this->parents array
+//     allocates and builds the this->parents array or
+//     this->secondary_parents based upon the isPrimary
+//     boolean.
 //
 //   Returns NULL on success and a static error string
 //     on failure
 //
 const char *
-ParentRecord::ProcessParents(char *val)
+ParentRecord::ProcessParents(char *val, bool isPrimary)
 {
   Tokenizer pTok(",; \t\r");
-  int numTok;
-  const char *current;
-  int port;
-  char *tmp, *tmp2;
-  const char *errPtr;
+  int numTok = 0;
+  const char *current = NULL;
+  int port = 0;
+  char *tmp = NULL, *tmp2 = NULL;
+  const char *errPtr = NULL;
   float weight = 1.0;
 
-  if (parents != NULL) {
+  if (parents != NULL && isPrimary == true) {
     return "Can not specify more than one set of parents";
   }
+  if (secondary_parents != NULL && isPrimary == false) {
+    return "Can not specify more than one set of secondary parents";
+  }
 
   numTok = pTok.Initialize(val, SHARE_TOKS);
 
@@ -722,7 +370,11 @@ ParentRecord::ProcessParents(char *val)
     return "No parents specified";
   }
   // Allocate the parents array
-  this->parents = (pRecord *)ats_malloc(sizeof(pRecord) * numTok);
+  if (isPrimary) {
+    this->parents = (pRecord *)ats_malloc(sizeof(pRecord) * numTok);
+  } else {
+    this->secondary_parents = (pRecord *)ats_malloc(sizeof(pRecord) * numTok);
+  }
 
   // Loop through the set of parents specified
   //
@@ -779,18 +431,35 @@ ParentRecord::ProcessParents(char *val)
       goto MERROR;
     }
     // Update the pRecords
-    memcpy(this->parents[i].hostname, current, tmp - current);
-    this->parents[i].hostname[tmp - current] = '\0';
-    this->parents[i].port = port;
-    this->parents[i].failedAt = 0;
-    this->parents[i].scheme = scheme;
-    this->parents[i].idx = i;
-    this->parents[i].name = this->parents[i].hostname;
-    this->parents[i].available = true;
-    this->parents[i].weight = weight;
+    if (isPrimary) {
+      memcpy(this->parents[i].hostname, current, tmp - current);
+      this->parents[i].hostname[tmp - current] = '\0';
+      this->parents[i].port = port;
+      this->parents[i].failedAt = 0;
+      this->parents[i].scheme = scheme;
+      this->parents[i].idx = i;
+      this->parents[i].name = this->parents[i].hostname;
+      this->parents[i].available = true;
+      this->parents[i].weight = weight;
+    } else {
+      memcpy(this->secondary_parents[i].hostname, current, tmp - current);
+      this->secondary_parents[i].hostname[tmp - current] = '\0';
+      this->secondary_parents[i].port = port;
+      this->secondary_parents[i].failedAt = 0;
+      this->secondary_parents[i].scheme = scheme;
+      this->secondary_parents[i].idx = i;
+      this->secondary_parents[i].name = this->secondary_parents[i].hostname;
+      this->secondary_parents[i].available = true;
+      this->secondary_parents[i].weight = weight;
+    }
+  }
+
+  if (isPrimary) {
+    num_parents = numTok;
+  } else {
+    num_secondary_parents = numTok;
   }
 
-  num_parents = numTok;
   return NULL;
 
 MERROR:
@@ -818,11 +487,10 @@ ParentRecord::DefaultInit(char *val)
   bool alarmAlready = false;
 
   this->go_direct = true;
-  this->round_robin = P_NO_ROUND_ROBIN;
   this->ignore_query = false;
   this->scheme = NULL;
   this->parent_is_proxy = true;
-  errPtr = ProcessParents(val);
+  errPtr = ProcessParents(val, true);
 
   if (errPtr != NULL) {
     errBuf = (char *)ats_malloc(1024);
@@ -835,23 +503,6 @@ ParentRecord::DefaultInit(char *val)
   }
 }
 
-void
-ParentRecord::buildConsistentHash(void)
-{
-  ATSHash64Sip24 hash;
-  int i;
-
-  if (chash) {
-    return;
-  }
-
-  chash = new ATSConsistentHash();
-
-  for (i = 0; i < num_parents; i++) {
-    chash->insert(&(this->parents[i]), this->parents[i].weight, (ATSHash64 *)&hash);
-  }
-}
-
 // config_parse_error ParentRecord::Init(matcher_line* line_info)
 //
 //    matcher_line* line_info - contains parsed label/value
@@ -869,6 +520,7 @@ ParentRecord::Init(matcher_line *line_info)
   char *label;
   char *val;
   bool used = false;
+  ParentRR_t round_robin = P_NO_ROUND_ROBIN;
 
   this->line_num = line_info->line_num;
   this->scheme = NULL;
@@ -891,20 +543,17 @@ ParentRecord::Init(matcher_line *line_info)
         round_robin = P_NO_ROUND_ROBIN;
       } else if (strcasecmp(val, "consistent_hash") == 0) {
         round_robin = P_CONSISTENT_HASH;
-        if (this->parents != NULL) {
-          buildConsistentHash();
-        }
       } else {
         round_robin = P_NO_ROUND_ROBIN;
         errPtr = "invalid argument to round_robin directive";
       }
       used = true;
-    } else if (strcasecmp(label, "parent") == 0) {
-      errPtr = ProcessParents(val);
+    } else if (strcasecmp(label, "parent") == 0 || strcasecmp(label, "primary_parent") == 0) {
+      errPtr = ProcessParents(val, true);
+      used = true;
+    } else if (strcasecmp(label, "secondary_parent") == 0) {
+      errPtr = ProcessParents(val, false);
       used = true;
-      if (round_robin == P_CONSISTENT_HASH) {
-        buildConsistentHash();
-      }
     } else if (strcasecmp(label, "go_direct") == 0) {
       if (strcasecmp(val, "false") == 0) {
         go_direct = false;
@@ -918,6 +567,8 @@ ParentRecord::Init(matcher_line *line_info)
       // qstring=ignore | consider
       if (strcasecmp(val, "ignore") == 0) {
         this->ignore_query = true;
+      } else {
+        this->ignore_query = false;
       }
       used = true;
     } else if (strcasecmp(label, "parent_is_proxy") == 0) {
@@ -961,6 +612,26 @@ ParentRecord::Init(matcher_line *line_info)
     }
   }
 
+  switch (round_robin) {
+  // ParentRecord.round_robin defaults to P_NO_ROUND_ROBIN when round_robin
+  // is not set in parent.config.  Therefore ParentRoundRobin is the default
+  // strategy.  If setting go_direct to true, there should be no parent list
+  // in parent.config and ParentRoundRobin::lookup will set parent_result->r
+  // to PARENT_DIRECT.
+  case P_NO_ROUND_ROBIN:
+  case P_STRICT_ROUND_ROBIN:
+  case P_HASH_ROUND_ROBIN:
+    TSDebug("parent_select", "allocating ParentRoundRobin() lookup strategy.");
+    selection_strategy = new ParentRoundRobin(this, round_robin);
+    break;
+  case P_CONSISTENT_HASH:
+    TSDebug("parent_select", "allocating ParentConsistentHash() lookup strategy.");
+    selection_strategy = new ParentConsistentHash(this);
+    break;
+  default:
+    ink_release_assert(0);
+  }
+
   return config_parse_error::ok();
 }
 
@@ -982,10 +653,8 @@ ParentRecord::UpdateMatch(ParentResult *result, RequestData *rdata)
 
 ParentRecord::~ParentRecord()
 {
-  if (chash) {
-    delete chash;
-  }
   ats_free(parents);
+  delete selection_strategy;
 }
 
 void
@@ -995,7 +664,7 @@ ParentRecord::Print()
   for (int i = 0; i < num_parents; i++) {
     printf(" %s:%d ", parents[i].hostname, parents[i].port);
   }
-  printf(" rr=%s direct=%s\n", ParentRRStr[round_robin], (go_direct == true) ? "true" : "false");
+  printf(" direct=%s\n", (go_direct == true) ? "true" : "false");
   printf(" parent_is_proxy=%s\n", ((parent_is_proxy == true) ? "true" : "false"));
 }
 
@@ -1069,7 +738,6 @@ setup_socks_servers(ParentRecord *rec_arr, int len)
   return 0;
 }
 
-
 void
 SocksServerConfig::reconfigure()
 {
@@ -1077,11 +745,13 @@ SocksServerConfig::reconfigure()
   int retry_time = 30;
   int fail_threshold;
 
-  ParentConfigParams *params;
-  params = new ParentConfigParams;
+  ParentConfigParams *params = NULL;
 
   // Allocate parent table
-  params->ParentTable = new P_table("proxy.config.socks.socks_config_file", "[Socks Server Selection]", &socks_server_tags);
+  P_table *pTable = new P_table("proxy.config.socks.socks_config_file", "[Socks Server Selection]", &socks_server_tags);
+
+  params = new ParentConfigParams(pTable);
+  ink_assert(params != NULL);
 
   // Handle default parent
   PARENT_ReadConfigStringAlloc(default_val, "proxy.config.socks.default_servers");
@@ -1090,24 +760,24 @@ SocksServerConfig::reconfigure()
 
   if (params->DefaultParent)
     setup_socks_servers(params->DefaultParent, 1);
-  if (params->ParentTable->ipMatch)
-    setup_socks_servers(params->ParentTable->ipMatch->data_array, params->ParentTable->ipMatch->array_len);
+  if (params->parent_table->ipMatch)
+    setup_socks_servers(params->parent_table->ipMatch->data_array, params->parent_table->ipMatch->array_len);
 
   // Handle parent timeout
   PARENT_ReadConfigInteger(retry_time, "proxy.config.socks.server_retry_time");
-  params->ParentRetryTime = retry_time;
+  params->policy.ParentRetryTime = retry_time;
 
   // Handle parent enable
   // enable is always true for use. We will come here only if socks is enabled
-  params->ParentEnable = 1;
+  params->policy.ParentEnable = 1;
 
   // Handle the fail threshold
   PARENT_ReadConfigInteger(fail_threshold, "proxy.config.socks.server_fail_threshold");
-  params->FailThreshold = fail_threshold;
+  params->policy.FailThreshold = fail_threshold;
 
   // Handle dns parent only
   // PARENT_ReadConfigInteger(dns_parent_only, dns_parent_only_var);
-  params->DNS_ParentOnly = 0;
+  params->policy.DNS_ParentOnly = 0;
 
   m_id = configProcessor.set(m_id, params);
 
@@ -1122,7 +792,8 @@ SocksServerConfig::print()
   ParentConfigParams *params = SocksServerConfig::acquire();
 
   printf("Parent Selection Config for Socks Server\n");
-  printf("\tEnabled %d\tRetryTime %d\tParent DNS Only %d\n", params->ParentEnable, params->ParentRetryTime, params->DNS_ParentOnly);
+  printf("\tEnabled %d\tRetryTime %d\tParent DNS Only %d\n", params->policy.ParentEnable, params->policy.ParentRetryTime,
+         params->policy.DNS_ParentOnly);
   if (params->DefaultParent == NULL) {
     printf("\tNo Default Parent\n");
   } else {
@@ -1130,7 +801,7 @@ SocksServerConfig::print()
     params->DefaultParent->Print();
   }
   printf("  ");
-  params->ParentTable->Print();
+  params->parent_table->Print();
 
   SocksServerConfig::release(params);
 }
@@ -1170,18 +841,20 @@ EXCLUSIVE_REGRESSION_TEST(PARENTSELECTION)(RegressionTest * /* t ATS_UNUSED */,
   // first, set everything up
   *pstatus = REGRESSION_TEST_INPROGRESS;
   ParentConfig config;
-  ParentConfigParams *params = new ParentConfigParams();
-  params->FailThreshold = 1;
-  params->ParentRetryTime = 5;
+  ParentConfigParams *params;
+  P_table *ParentTable;
   passes = fails = 0;
   config.startup();
-  params->ParentEnable = true;
   char tbl[2048];
 #define T(x) ink_strlcat(tbl, x, sizeof(tbl));
-#define REBUILD                                                                                                                  \
-  params->ParentTable = new P_table("", "ParentSelection Unit Test Table", &http_dest_tags,                                      \
-                                    ALLOW_HOST_TABLE | ALLOW_REGEX_TABLE | ALLOW_URL_TABLE | ALLOW_IP_TABLE | DONT_BUILD_TABLE); \
-  params->ParentTable->BuildTableFromString(tbl);
+#define REBUILD                                                                                                          \
+  ParentTable = new P_table("", "ParentSelection Unit Test Table", &http_dest_tags,                                      \
+                            ALLOW_HOST_TABLE | ALLOW_REGEX_TABLE | ALLOW_URL_TABLE | ALLOW_IP_TABLE | DONT_BUILD_TABLE); \
+  ParentTable->BuildTableFromString(tbl);                                                                                \
+  params = new ParentConfigParams(ParentTable);                                                                          \
+  params->policy.FailThreshold = 1;                                                                                      \
+  params->policy.ParentEnable = true;                                                                                    \
+  params->policy.ParentRetryTime = 5;
   HttpRequestData *request = NULL;
   ParentResult *result = NULL;
 #define REINIT                            \
@@ -1367,7 +1040,7 @@ EXCLUSIVE_REGRESSION_TEST(PARENTSELECTION)(RegressionTest * /* t ATS_UNUSED */,
   }
 
   // sleep(5); // parents should come back up; they don't
-  sleep(params->ParentRetryTime + 1);
+  sleep(params->policy.ParentRetryTime + 1);
 
   // Fix: The following tests failed because
   // br() should set xact_start correctly instead of 0.
@@ -1389,6 +1062,48 @@ EXCLUSIVE_REGRESSION_TEST(PARENTSELECTION)(RegressionTest * /* t ATS_UNUSED */,
       ink_assert(0);
     }
   }
+
+  // Test 173
+  tbl[0] = '\0';
+  ST(173)
+  T("dest_domain=rabbit.net parent=fuzzy:80|1.0;fluffy:80|1.0 secondary_parent=furry:80|1.0;frisky:80|1.0 "
+    "round_robin=consistent_hash go_direct=false\n")
+  REBUILD
+  REINIT br(request, "i.am.rabbit.net");
+  FP sleep(1);
+  RE(verify(result, PARENT_SPECIFIED, "fuzzy", 80), 173)
+  params->markParentDown(result); // fuzzy is down.
+
+  // Test 174
+  ST(174)
+  REINIT br(request, "i.am.rabbit.net");
+  FP sleep(1);
+  RE(verify(result, PARENT_SPECIFIED, "frisky", 80), 174)
+
+  params->markParentDown(result); // frisky is down.
+
+  // Test 175
+  ST(175)
+  REINIT br(request, "i.am.rabbit.net");
+  FP sleep(1);
+  RE(verify(result, PARENT_SPECIFIED, "furry", 80), 175)
+
+  params->markParentDown(result); // frisky is down.
+
+  // Test 176
+  ST(176)
+  REINIT br(request, "i.am.rabbit.net");
+  FP sleep(1);
+  RE(verify(result, PARENT_SPECIFIED, "fluffy", 80), 176)
+
+  params->markParentDown(result); // all are down now.
+
+  // Test 177
+  ST(177)
+  REINIT br(request, "i.am.rabbit.net");
+  FP sleep(1);
+  RE(verify(result, PARENT_FAIL, NULL, 80), 177)
+
   delete request;
   delete result;
   delete params;
diff --git a/proxy/ParentSelection.h b/proxy/ParentSelection.h
index 1907a42..ab970c0 100644
--- a/proxy/ParentSelection.h
+++ b/proxy/ParentSelection.h
@@ -35,20 +35,16 @@
 #include "ProxyConfig.h"
 #include "ControlBase.h"
 #include "ControlMatcher.h"
-
 #include "ink_apidefs.h"
-
 #include "P_RecProcess.h"
 
-#include "libts.h"
-
 #define MAX_PARENTS 64
 
 struct RequestData;
-
 struct matcher_line;
 struct ParentResult;
 class ParentRecord;
+class ParentSelectionStrategy;
 
 enum ParentResultType {
   PARENT_UNDEFINED,
@@ -59,23 +55,94 @@ enum ParentResultType {
   PARENT_ORIGIN,
 };
 
+enum ParentRR_t {
+  P_NO_ROUND_ROBIN = 0,
+  P_STRICT_ROUND_ROBIN,
+  P_HASH_ROUND_ROBIN,
+  P_CONSISTENT_HASH,
+};
+
+// struct pRecord
+//
+//    A record for an invidual parent
+//
+struct pRecord : ATSConsistentHashNode {
+  char hostname[MAXDNAME + 1];
+  int port;
+  time_t failedAt;
+  int failCount;
+  int32_t upAt;
+  const char *scheme; // for which parent matches (if any)
+  int idx;
+  float weight;
+};
+
 typedef ControlMatcher<ParentRecord, ParentResult> P_table;
 
+// class ParentRecord : public ControlBase
 //
-// API to outside world
+//   A record for a configuration line in the parent.config
+//    file
 //
+class ParentRecord : public ControlBase
+{
+public:
+  ParentRecord()
+    : parents(NULL), secondary_parents(NULL), num_parents(0), num_secondary_parents(0), ignore_query(false), rr_next(0),
+      go_direct(true), parent_is_proxy(true), selection_strategy(NULL)
+  {
+  }
+
+  ~ParentRecord();
+
+  config_parse_error Init(matcher_line *line_info);
+  bool DefaultInit(char *val);
+  void UpdateMatch(ParentResult *result, RequestData *rdata);
+  void Print();
+  pRecord *parents;
+  pRecord *secondary_parents;
+  int num_parents;
+  int num_secondary_parents;
+
+  bool
+  bypass_ok() const
+  {
+    return go_direct;
+  }
+  bool
+  isParentProxy() const
+  {
+    return parent_is_proxy;
+  }
+
+  const char *scheme;
+  // private:
+  const char *ProcessParents(char *val, bool isPrimary);
+  bool ignore_query;
+  volatile uint32_t rr_next;
+  bool go_direct;
+  bool parent_is_proxy;
+  ParentSelectionStrategy *selection_strategy;
+};
+
+// If the parent was set by the external customer api,
+//   our HttpRequestData structure told us what parent to
+//   use and we are only called to preserve clean interface
+//   between HttpTransact & the parent selection code.  The following
+ParentRecord *const extApiRecord = (ParentRecord *)0xeeeeffff;
+
 struct ParentResult {
   ParentResult()
-    : r(PARENT_UNDEFINED), hostname(NULL), port(0), line_number(0), epoch(NULL), rec(NULL), last_parent(0), start_parent(0),
-      wrap_around(false), retry(false)
+    : r(PARENT_UNDEFINED), hostname(NULL), port(0), retry(false), line_number(0), epoch(NULL), rec(NULL), last_parent(0),
+      start_parent(0), wrap_around(false), last_lookup(0)
   {
-    memset(foundParents, 0, sizeof(foundParents));
-  };
+  }
 
   // For outside consumption
   ParentResultType r;
   const char *hostname;
   int port;
+  bool retry;
 
   // Internal use only
   //   Not to be modified by HTTP
@@ -85,155 +152,119 @@ struct ParentResult {
   uint32_t last_parent;
   uint32_t start_parent;
   bool wrap_around;
-  bool retry;
-  // Arena *a;
-  ATSConsistentHashIter chashIter;
-  bool foundParents[MAX_PARENTS];
+  int last_lookup; // state for for consistent hash.
+  ATSConsistentHashIter chashIter[2];
 };
 
-class HttpRequestData;
-
-struct ParentConfigParams : public ConfigInfo {
-  ParentConfigParams();
-  ~ParentConfigParams();
+struct ParentSelectionPolicy {
+  int32_t ParentRetryTime;
+  int32_t ParentEnable;
+  int32_t FailThreshold;
+  int32_t DNS_ParentOnly;
+  ParentSelectionPolicy();
+};
 
-  // void findParent(RequestData* rdata, ParentResult* result)
+//
+// API definition.
+class ParentSelectionStrategy
+{
+public:
+  // void selectParent(const ParentSelectionPolicy *policy, bool firstCall, ParentResult *result, RequestData *rdata)
   //
-  //   Does initial parent lookup
+  // The implementation parent lookup.
   //
-  inkcoreapi void findParent(HttpRequestData *rdata, ParentResult *result);
+  virtual void selectParent(const ParentSelectionPolicy *policy, bool firstCall, ParentResult *result, RequestData *rdata) = 0;
 
-  // void markParentDown(ParentResult* rsult)
+  // void markParentDown(const ParentSelectionPolicy *policy, ParentResult* rsult)
   //
   //    Marks the parent pointed to by result as down
   //
-  inkcoreapi void markParentDown(ParentResult *result);
-
-  // void recordRetrySuccess
-  //
-  //    After a successful retry, http calls this function
-  //      to clear the bits indicating the parent is down
-  //
-  void recordRetrySuccess(ParentResult *result);
+  virtual void markParentDown(const ParentSelectionPolicy *policy, ParentResult *result) = 0;
 
-  // void nextParent(RequestData* rdata, ParentResult* result);
+  // uint32_t numParents(ParentResult *result);
   //
-  //    Marks the parent pointed to by result as down and attempts
-  //      to find the next parent
+  // Returns the number of parent records in a strategy.
   //
-  inkcoreapi void nextParent(HttpRequestData *rdata, ParentResult *result);
+  virtual uint32_t numParents(ParentResult *result) const = 0;
 
-  // bool parentExists(HttpRequestData* rdata)
+  // void markParentUp
   //
-  //   Returns true if there is a parent matching the request data and
-  //   false otherwise
-  bool parentExists(HttpRequestData *rdata);
-
-  // bool apiParentExists(HttpRequestData* rdata)
+  //    After a successful retry, http calls this function
+  //      to clear the bits indicating the parent is down
   //
-  //   Retures true if a parent has been set through the api
-  bool apiParentExists(HttpRequestData *rdata);
+  virtual void markParentUp(ParentResult *result) = 0;
 
-  P_table *ParentTable;
-  ParentRecord *DefaultParent;
-  int32_t ParentRetryTime;
-  int32_t ParentEnable;
-  int32_t FailThreshold;
-  int32_t DNS_ParentOnly;
+  // virtual destructor.
+  virtual ~ParentSelectionStrategy(){};
 };
 
-struct ParentConfig {
+class ParentConfigParams : public ConfigInfo
+{
 public:
-  static void startup();
-  static void reconfigure();
-  static void print();
+  explicit ParentConfigParams(P_table *_parent_table);
+  ~ParentConfigParams(){};
 
-  inkcoreapi static ParentConfigParams *
-  acquire()
+  bool apiParentExists(HttpRequestData *rdata);
+  void findParent(HttpRequestData *rdata, ParentResult *result);
+  void nextParent(HttpRequestData *rdata, ParentResult *result);
+  bool parentExists(HttpRequestData *rdata);
+
+  // implementation of functions from ParentSelectionStrategy.
+  void
+  selectParent(bool firstCall, ParentResult *result, RequestData *rdata)
   {
-    return (ParentConfigParams *)configProcessor.get(ParentConfig::m_id);
+    ink_release_assert(result->rec->selection_strategy != NULL);
+    return result->rec->selection_strategy->selectParent(&policy, firstCall, result, rdata);
   }
-  inkcoreapi static void
-  release(ParentConfigParams *params)
+
+  void
+  markParentDown(ParentResult *result)
   {
-    configProcessor.release(ParentConfig::m_id, params);
+    ink_release_assert(result->rec->selection_strategy != NULL);
+    result->rec->selection_strategy->markParentDown(&policy, result);
   }
 
+  uint32_t
+  numParents(ParentResult *result)
+  {
+    ink_release_assert(result->rec->selection_strategy != NULL);
+    return result->rec->selection_strategy->numParents(result);
+  }
 
-  static int m_id;
-};
-//
-// End API to outside world
-//
-
+  void
+  markParentUp(ParentResult *result)
+  {
+    ink_release_assert(result != NULL);
+    result->rec->selection_strategy->markParentUp(result);
+  }
 
-// struct pRecord
-//
-//    A record for an invidual parent
-//
-struct pRecord : ATSConsistentHashNode {
-  char hostname[MAXDNAME + 1];
-  int port;
-  time_t failedAt;
-  int failCount;
-  int32_t upAt;
-  const char *scheme; // for which parent matches (if any)
-  int idx;
-  float weight;
+  P_table *parent_table;
+  ParentRecord *DefaultParent;
+  ParentSelectionPolicy policy;
 };
 
-enum ParentRR_t {
-  P_NO_ROUND_ROBIN = 0,
-  P_STRICT_ROUND_ROBIN,
-  P_HASH_ROUND_ROBIN,
-  P_CONSISTENT_HASH,
-};
+class HttpRequestData;
 
-// class ParentRecord : public ControlBase
-//
-//   A record for a configuration line in the parent.config
-//    file
-//
-class ParentRecord : public ControlBase
-{
+struct ParentConfig {
 public:
-  ParentRecord()
-    : parents(NULL), num_parents(0), round_robin(P_NO_ROUND_ROBIN), rr_next(0), go_direct(true), parent_is_proxy(true), chash(NULL)
-  {
-  }
-
-  ~ParentRecord();
-
-  config_parse_error Init(matcher_line *line_info);
-  bool DefaultInit(char *val);
-  void UpdateMatch(ParentResult *result, RequestData *rdata);
-  void FindParent(bool firstCall, ParentResult *result, RequestData *rdata, ParentConfigParams *config);
-  uint64_t getPathHash(HttpRequestData *hrdata, ATSHash64 *h);
-  void Print();
-  pRecord *parents;
-  int num_parents;
+  static void startup();
+  static void reconfigure();
+  static void print();
+  static void set_parent_table(P_table *pTable, ParentRecord *rec, int num_elements);
 
-  bool
-  bypass_ok() const
+  static ParentConfigParams *
+  acquire()
   {
-    return go_direct;
+    return (ParentConfigParams *)configProcessor.get(ParentConfig::m_id);
   }
-  bool
-  isParentProxy() const
+
+  static void
+  release(ParentConfigParams *strategy)
   {
-    return parent_is_proxy;
+    configProcessor.release(ParentConfig::m_id, strategy);
   }
 
-  const char *scheme;
-  // private:
-  const char *ProcessParents(char *val);
-  void buildConsistentHash(void);
-  ParentRR_t round_robin;
-  bool ignore_query;
-  volatile uint32_t rr_next;
-  bool go_direct;
-  bool parent_is_proxy;
-  ATSConsistentHash *chash;
+  static int m_id;
 };
 
 // Helper Functions
diff --git a/proxy/http/HttpSM.cc b/proxy/http/HttpSM.cc
index 2fc20b5..d53efea 100644
--- a/proxy/http/HttpSM.cc
+++ b/proxy/http/HttpSM.cc
@@ -414,7 +414,7 @@ HttpSM::init()
   // Added to skip dns if the document is in cache. DNS will be forced if there is a ip based ACL in
   // cache control or parent.config or if the doc_in_cache_skip_dns is disabled or if http caching is disabled
   // TODO: This probably doesn't honor this as a per-transaction overridable config.
-  t_state.force_dns = (ip_rule_in_CacheControlTable() || t_state.parent_params->ParentTable->ipMatch ||
+  t_state.force_dns = (ip_rule_in_CacheControlTable() || t_state.parent_params->parent_table->ipMatch ||
                        !(t_state.txn_conf->doc_in_cache_skip_dns) || !(t_state.txn_conf->cache_http));
 
   http_parser.m_allow_non_http = t_state.http_config_param->parser_allow_non_http;
diff --git a/proxy/http/HttpTransact.cc b/proxy/http/HttpTransact.cc
index b734a7d..f3ea5e4 100644
--- a/proxy/http/HttpTransact.cc
+++ b/proxy/http/HttpTransact.cc
@@ -209,7 +209,7 @@ find_server_and_update_current_info(HttpTransact::State *s)
   int host_len;
   const char *host = s->hdr_info.client_request.host_get(&host_len);
 
-  DebugTxn("http_trans", "starting find_server_adn_update_current_info()");
+  DebugTxn("http_trans", "starting find_server_and_update_current_info()");
   if (ptr_len_cmp(host, host_len, local_host_ip_str, sizeof(local_host_ip_str) - 1) == 0) {
     // Do not forward requests to local_host onto a parent.
     // I just wanted to do this for cop heartbeats, someone else
@@ -231,12 +231,6 @@ find_server_and_update_current_info(HttpTransact::State *s)
     switch (s->parent_result.r) {
     case PARENT_UNDEFINED:
       s->parent_params->findParent(&s->request_data, &s->parent_result);
-      if (s->parent_result.rec != NULL) {
-        // check to see if the parent is an origin server.
-        if (!s->parent_result.rec->isParentProxy()) {
-          s->parent_result.r = PARENT_ORIGIN;
-        }
-      }
       break;
     case PARENT_SPECIFIED:
     case PARENT_ORIGIN:
@@ -258,7 +252,7 @@ find_server_and_update_current_info(HttpTransact::State *s)
       //   2) the config permits us
       //   3) the config permitted us to dns the origin server
       if (!s->parent_params->apiParentExists(&s->request_data) && s->parent_result.rec->bypass_ok() &&
-          s->http_config_param->no_dns_forward_to_parent == 0) {
+          s->http_config_param->no_dns_forward_to_parent == 0 && s->parent_result.rec->isParentProxy()) {
         s->parent_result.r = PARENT_DIRECT;
       }
       break;
@@ -691,6 +685,8 @@ HttpTransact::StartRemapRequest(State *s)
   if (s->api_skip_all_remapping) {
     Debug("http_trans", "API request to skip remapping");
 
+    s->hdr_info.client_request.set_url_target_from_host_field();
+
     if (s->is_upgrade_request && s->post_remap_upgrade_return_point) {
       TRANSACT_RETURN(SM_ACTION_POST_REMAP_SKIP, s->post_remap_upgrade_return_point);
     }
@@ -1357,7 +1353,7 @@ HttpTransact::HandleRequest(State *s)
   // if the newly added varible doc_in_cache_skip_dns is not enabled
   if (s->dns_info.lookup_name[0] <= '9' && s->dns_info.lookup_name[0] >= '0' &&
       (!s->state_machine->enable_redirection || !s->redirect_info.redirect_in_process) &&
-      s->parent_params->ParentTable->hostMatch) {
+      s->parent_params->parent_table->hostMatch) {
     s->force_dns = 1;
   }
   // YTS Team, yamsat Plugin
@@ -1755,7 +1751,7 @@ HttpTransact::OSDNSLookup(State *s)
     // we've come back after already trying the server to get a better address
     // and finished with all backtracking - return to trying the server.
     TRANSACT_RETURN(how_to_open_connection(s), HttpTransact::HandleResponse);
-  } else if (s->dns_info.lookup_name[0] <= '9' && s->dns_info.lookup_name[0] >= '0' && s->parent_params->ParentTable->hostMatch &&
+  } else if (s->dns_info.lookup_name[0] <= '9' && s->dns_info.lookup_name[0] >= '0' && s->parent_params->parent_table->hostMatch &&
              !s->http_config_param->no_dns_forward_to_parent) {
     // note, broken logic: ACC fudges the OR stmt to always be true,
     // 'AuthHttpAdapter' should do the rev-dns if needed, not here .
@@ -2648,6 +2644,15 @@ HttpTransact::HandleCacheOpenReadHit(State *s)
         server_up = false;
         update_current_info(&s->current, NULL, UNDEFINED_LOOKUP, 0);
         DebugTxn("http_trans", "CacheOpenReadHit - server_down, returning stale document");
+      } else if (s->current.request_to == HOST_NONE && s->parent_result.r == PARENT_FAIL) {
+        if (is_server_negative_cached(s) && response_returnable == true && is_stale_cache_response_returnable(s) == true) {
+          server_up = false;
+          update_current_info(&s->current, NULL, UNDEFINED_LOOKUP, 0);
+          DebugTxn("http_trans", "CacheOpenReadHit - server_down, returning stale document");
+        } else {
+          handle_parent_died(s);
+          return;
+        }
       }
     }
 
@@ -3080,6 +3085,11 @@ HttpTransact::HandleCacheOpenReadMiss(State *s)
 
   if (!h->is_cache_control_set(HTTP_VALUE_ONLY_IF_CACHED)) {
     find_server_and_update_current_info(s);
+    // parent_result.r could come back set as PARENT_FAIL, need to check this.
+    if (s->parent_result.r == PARENT_FAIL) {
+      handle_parent_died(s);
+      return;
+    }
     if (!ats_is_ip(&s->current.server->addr)) {
       ink_release_assert(s->current.request_to == PARENT_PROXY || s->http_config_param->no_dns_forward_to_parent != 0);
       if (s->current.request_to == PARENT_PROXY) {
@@ -3470,23 +3480,23 @@ HttpTransact::handle_response_from_icp_suggested_host(State *s)
 void
 HttpTransact::handle_response_from_parent(State *s)
 {
-  DebugTxn("http_trans", "[handle_response_from_parent] (hrfp)");
+  DebugTxn("http_trans", "[%s] (hrfp)", __func__);
   HTTP_RELEASE_ASSERT(s->current.server == &s->parent_info);
 
   s->parent_info.state = s->current.state;
   switch (s->current.state) {
   case CONNECTION_ALIVE:
-    DebugTxn("http_trans", "[hrfp] connection alive");
+    DebugTxn("http_trans", "[%s] connection alive", __func__);
     s->current.server->connect_result = 0;
     SET_VIA_STRING(VIA_DETAIL_PP_CONNECT, VIA_DETAIL_PP_SUCCESS);
     if (s->parent_result.retry) {
-      s->parent_params->recordRetrySuccess(&s->parent_result);
+      s->parent_params->markParentUp(&s->parent_result);
     }
     handle_forward_server_connection_open(s);
     break;
   default: {
     LookingUp_t next_lookup = UNDEFINED_LOOKUP;
-    DebugTxn("http_trans", "[hrfp] connection not alive");
+    DebugTxn("http_trans", "[%s] connection not alive, s->current.state: %d", __func__, s->current.state);
     SET_VIA_STRING(VIA_DETAIL_PP_CONNECT, VIA_DETAIL_PP_FAILURE);
 
     ink_assert(s->hdr_info.server_request.valid());
@@ -3494,11 +3504,12 @@ HttpTransact::handle_response_from_parent(State *s)
     s->current.server->connect_result = ENOTCONN;
 
     char addrbuf[INET6_ADDRSTRLEN];
-    DebugTxn("http_trans", "[%d] failed to connect to parent %s", s->current.attempts,
-             ats_ip_ntop(&s->current.server->addr.sa, addrbuf, sizeof(addrbuf)));
+    DebugTxn("http_trans", "[%s] failed to connect to parent %s after %d attempts", __func__,
+             ats_ip_ntop(&s->current.server->addr.sa, addrbuf, sizeof(addrbuf)), s->current.attempts);
 
     // If the request is not retryable, just give up!
     if (!is_request_retryable(s)) {
+      DebugTxn("http_trans", "request is not retryable, marking parent down.");
       s->parent_params->markParentDown(&s->parent_result);
       s->parent_result.r = PARENT_FAIL;
       handle_parent_died(s);
@@ -3508,19 +3519,23 @@ HttpTransact::handle_response_from_parent(State *s)
     // try a simple retry if we received a simple retryable response from the parent.
     if (s->current.retry_type == SIMPLE_RETRY || s->current.retry_type == DEAD_SERVER_RETRY) {
       if (s->current.retry_type == SIMPLE_RETRY) {
-        if (s->current.simple_retry_attempts >= s->parent_result.rec->num_parents - 1) {
+        if (s->current.simple_retry_attempts >= (int)s->parent_params->numParents(&s->parent_result) - 1) {
           DebugTxn("http_trans", "SIMPLE_RETRY: retried all parents, send error to client.\n");
+          s->current.retry_type = UNDEFINED_RETRY;
         } else {
           s->current.simple_retry_attempts++;
           DebugTxn("http_trans", "SIMPLE_RETRY: try another parent.\n");
+          s->current.retry_type = UNDEFINED_RETRY;
           next_lookup = find_server_and_update_current_info(s);
         }
       } else { // DEAD_SERVER_RETRY
-        if (s->current.dead_server_retry_attempts >= s->parent_result.rec->num_parents - 1) {
+        if (s->current.dead_server_retry_attempts >= (int)s->parent_params->numParents(&s->parent_result) - 1) {
           DebugTxn("http_trans", "DEAD_SERVER_RETRY: retried all parents, send error to client.\n");
+          s->current.retry_type = UNDEFINED_RETRY;
         } else {
           s->current.dead_server_retry_attempts++;
           DebugTxn("http_trans", "DEAD_SERVER_RETRY: marking parent down and trying another.\n");
+          s->current.retry_type = UNDEFINED_RETRY;
           s->parent_params->markParentDown(&s->parent_result);
           next_lookup = find_server_and_update_current_info(s);
         }
@@ -3537,17 +3552,17 @@ HttpTransact::handle_response_from_parent(State *s)
       if ((s->current.attempts - 1) % s->txn_conf->per_parent_connect_attempts != 0) {
         // No we are not done with this parent so retry
         s->next_action = how_to_open_connection(s);
-        DebugTxn("http_trans", "%s Retrying parent for attempt %d, max %" PRId64, "[handle_response_from_parent]",
-                 s->current.attempts, s->txn_conf->per_parent_connect_attempts);
+        DebugTxn("http_trans", "[%s] Retrying parent for attempt %d, max %d", __func__, s->current.attempts,
+                 (int)s->txn_conf->per_parent_connect_attempts);
         return;
       } else {
-        DebugTxn("http_trans", "%s %d per parent attempts exhausted, s->current.state: %d", "[handle_response_from_parent]",
-                 s->current.attempts, s->current.state);
+        DebugTxn("http_trans", "[%s] %d per parent attempts exhausted, s->current.state: %d", __func__, s->current.attempts,
+                 s->current.state);
 
         // Only mark the parent down if we failed to connect
         //  to the parent otherwise slow origin servers cause
         //  us to mark the parent down
-        if (s->current.state != ACTIVE_TIMEOUT && s->current.state != CONNECTION_ALIVE && s->current.state != CONNECTION_CLOSED) {
+        if (s->current.state == CONNECTION_ERROR) {
           s->parent_params->markParentDown(&s->parent_result);
         }
         // We are done so look for another parent if any
@@ -3556,7 +3571,7 @@ HttpTransact::handle_response_from_parent(State *s)
     } else {
       // Done trying parents... fail over to origin server if that is
       //   appropriate
-      DebugTxn("http_trans", "[handle_response_from_parent] Error. No more retries.");
+      DebugTxn("http_trans", "[%s] Error. No more retries.", __func__);
       s->parent_params->markParentDown(&s->parent_result);
       s->parent_result.r = PARENT_FAIL;
       next_lookup = find_server_and_update_current_info(s);
@@ -5031,6 +5046,11 @@ HttpTransact::get_ka_info_from_config(State *s, ConnectionAttributes *server_inf
 {
   bool check_hostdb = false;
 
+  if (!server_info) {
+    TSError("[%s:%d] - Connection attributes are null, unable to set keep-alive and version flags.", __FILE__, __LINE__);
+    return false;
+  }
+
   if (server_info->http_version > HTTPVersion(0, 9)) {
     DebugTxn("http_trans", "get_ka_info_from_config, version already set server_info->http_version %d",
              server_info->http_version.m_version);
@@ -6425,14 +6445,16 @@ HttpTransact::is_response_valid(State *s, HTTPHdr *incoming_response)
   // is this response is from a load balanced parent.
   if (s->current.request_to == PARENT_PROXY && s->parent_result.r == PARENT_ORIGIN) {
     server_response = http_hdr_status_get(s->hdr_info.server_response.m_http);
-    DebugTxn("http_trans", "[is_response_valid] server_response = %d\n", server_response);
+    DebugTxn("http_trans", "[is_response_valid] server_response = %d, simple_retry_attempts: %d, numParents:%d \n", server_response,
+             s->current.simple_retry_attempts, s->parent_params->numParents(&s->parent_result));
     // is a simple retry required.
-    if (s->txn_conf->simple_retry_enabled && (s->current.simple_retry_attempts < s->parent_result.rec->num_parents - 1) &&
+    if (s->txn_conf->simple_retry_enabled &&
+        (s->current.simple_retry_attempts < (int)s->parent_params->numParents(&s->parent_result) - 1) &&
         s->http_config_param->response_codes->contains(server_response, s->txn_conf->simple_retry_response_codes_string)) {
       DebugTxn("parent_select", "GOT A SIMPLE RETRY RESPONSE");
       // initiate a retry if we have not already tried all parents, otherwise the response is sent to the client as is.
       // see SIMPLE_RETRY in handle_response_from_parent().
-      if (s->current.simple_retry_attempts < s->parent_result.rec->num_parents) {
+      if (s->current.simple_retry_attempts < (int)s->parent_params->numParents(&s->parent_result)) {
         s->current.state = BAD_INCOMING_RESPONSE;
         s->current.retry_type = SIMPLE_RETRY;
       } else {
@@ -6441,13 +6463,13 @@ HttpTransact::is_response_valid(State *s, HTTPHdr *incoming_response)
     }
     // is a dead server retry required.
     else if (s->txn_conf->dead_server_retry_enabled &&
-             (s->current.dead_server_retry_attempts < s->parent_result.rec->num_parents - 1) &&
+             (s->current.dead_server_retry_attempts < (int)s->parent_params->numParents(&s->parent_result) - 1) &&
              s->http_config_param->response_codes->contains(server_response,
                                                             s->txn_conf->dead_server_retry_response_codes_string)) {
       DebugTxn("parent_select", "GOT A DEAD_SERVER RETRY RESPONSE");
       // initiate a dead server retry if we have not already tried all parents, otherwise the response is sent to the client as is.
       // see DEAD_SERVER_RETRY in handle_response_from_parent().
-      if (s->current.dead_server_retry_attempts < s->parent_result.rec->num_parents) {
+      if (s->current.dead_server_retry_attempts < (int)s->parent_params->numParents(&s->parent_result)) {
         s->current.state = BAD_INCOMING_RESPONSE;
         s->current.retry_type = DEAD_SERVER_RETRY;
       } else {
